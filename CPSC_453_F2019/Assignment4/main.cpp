/**
 * This program implements an interactive environment for creating a pottery
 * by drawing its profile curve and lathing (a surface of revolution),
 * the user can:
 *
 * 1. Choose the method to generate the curve (Bezier curve/B-spline curve)
 * 2. Inserting, deleting and moving control points for a Bezier curve
 * 3. Inserting, deleting and moving points of a B-spline curve before subdivision
 * 4. Switch the viewport between profile/perspective/parallel projection
 * 5. Applied a pre-define checkerboard procedural texture on the model
 * 6. Adjust the direction of the directional light
 * 7. Save the model by its position of control points/points before subdivision
 *    as well as the corresponding type of curve as .dat files.
 * 8. Re-create the model by loading .dat files.
 *
 * Notice:
 * 1. The program has been tested in MS239.
 * 3. The default number of points of Bezier curve generated by de Casteljau's
 *    algorithm is 1000.
 * 4. 'The chasing game' subdivision scheme on a B-spline open curve will stop
 *    once the number of points generated >= 1000
 * 5. I assume that the pottery should be placed on a horizontal line,
 *    so I restricted its profile such that in xy-plane of NDC,
 *    -1.0 <= x <= 0.0, -0.9 <= y <= 1.0
 *
 * Author: Haohu Shen (UCID: 30063099)
 * Date:   2019.11.27
 */

#include "glad/glad.h"
#include <GLFW/glfw3.h>
#include <glm/glm.hpp>
#include <glm/ext.hpp>
#include <glm/gtx/string_cast.hpp>
#include <bits/stdc++.h>
#include <experimental/filesystem>
#include <omp.h>
#include <parallel/algorithm>

// A boolean indicates 'true' if I am running it on my laptop
// otherwise it indicates it is running on MS239
static bool useCLion = false;

// Namespace: Utility
// Description: The namespace includes all miscellaneous methods
namespace Utility {

    // Three-way-compare the float number and the zero
    // result = 1: larger than 0
    // result = 0: equal to 0
    // result = -1: smaller than 0
    inline
    int threeWayComparator(const float &a) {
        constexpr double Eps = 1e-8;
        if (a > Eps) {
            return 1;
        }
        if (a > -Eps) {
            return 0;
        }
        return -1;
    }

    // Check if 'filename' is a regular file instead of a directory
    inline
    bool isRegularFile(const std::string &filename) {
        return std::experimental::filesystem::is_regular_file(filename);
    }

    // Check if 'filename' has .glsl as its suffix
    inline
    bool isGlslFile(const std::string &filename) {
        return std::experimental::filesystem::path(filename).extension() ==
               ".glsl";
    }

    // Check if 'filename' has .dat as its suffix
    inline
    bool isDatFile(const std::string &filename) {
        return std::experimental::filesystem::path(filename).extension() ==
               ".dat";
    }

    // Check if the user has the permission to read 'filename'.
    inline
    bool
    hasReadPermission(const std::experimental::filesystem::path &filename) {
        auto perm = std::experimental::filesystem::status(
                filename).permissions();
        return (perm & std::experimental::filesystem::perms::owner_read) !=
               std::experimental::filesystem::perms::none;
    }

    // Clamp n between lower-bound and upper-bound
    template<typename T>
    inline
    void
    clamp(T &n, const T &lowerBound, const T &upperBound) {
        static_assert(
                std::is_same<int, T>::value ||
                std::is_same<float, T>::value ||
                std::is_same<double, T>::value ||
                std::is_same<unsigned int, T>::value);
        n = std::min(std::max(n, lowerBound), upperBound);
    }

    // Convert RGB unsigned integers to the corresponding float between 0.0f-1.0f
    // and store in a glm::vec3
    inline
    glm::vec3
    rgb2float(const unsigned int &r, const unsigned int &g,
              const unsigned int &b) {
        return glm::vec3(
                static_cast<float>(r) / 255.0f,
                static_cast<float>(g) / 255.0f,
                static_cast<float>(b) / 255.0f);
    }

    // A helper function to split a string by using whitespaces with unknown length as delimiter
    inline
    std::vector<std::string> splitByWhitespaces(const std::string &s) {
        std::istringstream iss(s);
        return std::vector<std::string>{std::istream_iterator<std::string>(iss),
                                        std::istream_iterator<std::string>()};
    }

    // Check if there is an OpenGL error, print the error message and abort the program if it is true.
    void CheckGLErrors(const char *errorLocation = nullptr) {
        bool error = false;
        for (GLenum flag = glGetError();
             flag != GL_NO_ERROR; flag = glGetError()) {

            // Print the location is the argument is given
            if (errorLocation) {
                fprintf(stderr, "%s: ", errorLocation);
            }
            fprintf(stderr, "OpenGL ERROR:  ");
            switch (flag) {
                case GL_INVALID_ENUM:
                    fprintf(stderr, "GL_INVALID_ENUM\n");
                    break;
                case GL_INVALID_VALUE:
                    fprintf(stderr, "GL_INVALID_VALUE\n");
                    break;
                case GL_INVALID_OPERATION:
                    fprintf(stderr, "GL_INVALID_OPERATION\n");
                    break;
                case GL_INVALID_FRAMEBUFFER_OPERATION:
                    fprintf(stderr, "GL_INVALID_FRAMEBUFFER_OPERATION\n");
                    break;
                case GL_OUT_OF_MEMORY:
                    fprintf(stderr, "GL_OUT_OF_MEMORY\n");
                    break;
                default:
                    fprintf(stderr, "[unknown error code]\n");
            }
            error = true;
        }
        if (error) {
            exit(EXIT_FAILURE);
        }
    }

    // Hash of a glm::vec2
    struct glm_vec2_hash {
        std::size_t operator()(const glm::vec2 &obj) const noexcept {
            std::size_t h1 = std::hash<float>{}(obj.x);
            std::size_t h2 = std::hash<float>{}(obj.y);
            return h1 ^ (h2 << 1);
        }
    };
}

/**
 * Forward declaration of all classes.
 */
class Scene;

class Program;

class Geometry;

class RenderingEngine;

class Shader;

/** All constants used in the profile projection **/
// Mouse constants
static constexpr double THRESHOLD = 0.0001;
// Object color constants
static const auto YELLOW = Utility::rgb2float(255, 222, 55);
static const auto GREEN = Utility::rgb2float(29, 205, 144);
static const auto GRAY = Utility::rgb2float(128, 128, 128);
static const auto BLUE = Utility::rgb2float(48, 106, 219);
static const auto RED = Utility::rgb2float(203, 45, 34);
static const auto WHITE = glm::vec3(1.0f, 1.0f, 1.0f);

/** All global variables used in the profile projection **/
static int indexOfPointSelected = -1;   // -1 indicates no points are selected
static bool insertMode = false;
static bool isModified = false; // true indicates that the profile has been modified
static float pointSize;
static size_t bspline_segment_threshold;

/** All constants used in the perspective/parallel projection **/
// Constants of the light source (the type of light: directional light)
static const glm::vec3 DEFAULT_LIGHT_DIRECTION = glm::vec3(-10.0f, 10.0f,
                                                           10.0f);
static const glm::vec3 DEFAULT_LIGHT_COLOR = WHITE;
static const GLfloat DEFAULT_LIGHT_DIRECTION_INCREMENT = 1.5f;
// Text constants
static const char *DELIMITER = "\n----------------------------------------------------------\n";
static const std::string DEFAULT_COLOR("\033[0m");
static const std::string WHITE_BOLD_STRING("\033[1;37m");
// Camera constants
static constexpr GLfloat DEFAULT_ANGLE = 0.0f;
static constexpr GLfloat DEFAULT_ZOOM = 0.5f;
static constexpr GLfloat MINIMAL_ZOOM = 0.03f;
static constexpr GLfloat DEFAULT_FOV = 30.0f;
static constexpr glm::vec3 DEFAULT_UP_VECTOR = glm::vec3(0.0f, 1.0f, 0.0f);
static constexpr glm::vec3 DEFAULT_EYE = glm::vec3(0.0f, -4.5f, 3.5f);
static constexpr glm::vec3 DEFAULT_TARGET = glm::vec3(0.0f, 0.0f, 0.0f);
// Mouse constants
static constexpr GLfloat MAXIMAL_OFFSET = 20.0f;
// Texture constants
static constexpr unsigned int IMAGE_HEIGHT = 2;
static constexpr unsigned int IMAGE_WIDTH = 2;

/** All global variables used in the perspective/parallel projection **/
// Global variables for the light
static glm::vec3 lightDirection = DEFAULT_LIGHT_DIRECTION;
static glm::vec3 lightColor = DEFAULT_LIGHT_COLOR;
static glm::vec3 lightAmbientStrength;
static glm::vec3 lightAmbient;
static glm::vec3 lightDiffuse;
static glm::vec3 lightSpecularStrength;

// Global variables for the material
static glm::vec3 materialAmbient;
static glm::vec3 materialDiffuse;
static glm::vec3 materialSpecular;
static float shininess;

// Global variables for the camera
static bool isOrtho = false;
static bool zoomMode = false;

static float zoom = DEFAULT_ZOOM;
static float angleZ = DEFAULT_ANGLE;
static float angleX = DEFAULT_ANGLE;

static glm::vec3 eye = DEFAULT_EYE;
static glm::vec3 target = DEFAULT_TARGET;
static glm::vec3 upVector = DEFAULT_UP_VECTOR;

// Global variables for the model
static bool useTexture = false;
static GLubyte checkerBoard[IMAGE_HEIGHT][IMAGE_WIDTH][4];
static GLuint textureID;

/** Other global variables **/
// An integer indicates how many threads we are gonna use for parallel acceleration by OpenMP
static int numberOfThreads;

// Global variables for the mouse
static bool isLeftButtonPressed = false;
static bool isRightButtonPressed = false;
static bool firstMoveAfterSwitch = false;

// The global variables of the window
static int windowHeight;
static int windowWidth;

// define the method to generate the curve
// 1. Use de Casteljau's algorithm to generate Parametric Bezier curve
// 2. Use 'The chasing game' open curve subdivision scheme to generate B-spline
static int method;

// viewport:
// 1: wireframe of the shape which is coplanar to xy-plane
// 2: the perspective projection of the pottery with material/procedural texture
// 3: the parallel projection of the pottery with material/procedural texture
// 4: the default viewport is 1
static int viewport = 1;

// Global variables for shaders
static std::shared_ptr<Shader> shaderOfModel = nullptr;
static std::shared_ptr<Shader> shaderOfProfile = nullptr;

// pointsList stores all points used in the profile
// it only contains 2 elements, the first element is the lines connected
// each adjacent point as a line strip
// the second element is the collection of all points
static std::vector<Geometry> pointsList;
// objectsList stores all objects used in the perspective/parallel projection
static std::vector<Geometry> objectsList;

/**
 * Forward declaration of all functions defined outside namespaces and classes.
 */
inline static
void errorCallback(int error, const char *description);

inline static
void
keyCallback(GLFWwindow *window, int key, int scancode, int action, int mods);

inline static
void windowCloseCallback(GLFWwindow *window);

inline static
void mouseCursorCallback(GLFWwindow *window, double x, double y);

inline static
void mouseButtonCallback(GLFWwindow *window, int key, int action, int mods);

inline static
void frameBufferSizeCallback(GLFWwindow *window, int width, int height);

inline static
void colorPrint(const std::string &colorType, const std::string &output);

inline static
void queryBasicInformation(GLFWwindow *window);

inline static
bool comparator(const glm::vec3 &lhs, const glm::vec3 &rhs);

inline static
std::pair<double, double> pixel2Coord(
        const double &mouse_x,
        const double &mouse_y,
        const int &window_width,
        const int &window_height);

inline static
void insertAPoint(GLFWwindow *window);

inline static
void moveAPoint(GLFWwindow *window, double x, double y);

inline static
void selectAPoint(GLFWwindow *window);

inline static
void deselectAPoint();

inline static
void deleteSelectedPoint();

std::vector<std::tuple<glm::vec3, glm::vec3, glm::vec2> >
lathe(const std::vector<glm::vec3> &pts,
      unsigned int segments);

inline static
std::vector<glm::vec3> deCasteljau(
        const std::vector<glm::vec3> &controlPoints,
        unsigned int segments);

inline static
void chasingGame(std::vector<glm::vec3> &points);

inline static
void serialize();

inline static
void deserialize(const std::string &filename);

inline static
void printLightDirection();

inline static
void generateCheckerboard();

inline static
void bindTexture();

inline static
void destroyTexture();

inline static
void printUsage();

inline static
void argumentsValidation(int argc, char *argv[]);

/**
 * A user-defined object for modeling.
 */
class Geometry {
public:

    // Constructor
    Geometry() :
            vao(0),
            vertexBuffer(0),
            normalBuffer(0),
            uvBuffer(0),
            colorBuffer(0),
            ebo(0),
            texture(0),
            drawMode(0) {}

    // Destructor
    ~Geometry() = default;

    // Data structures for storing vectors of vertices, normals and colors
    std::vector<glm::vec3> vertices;
    std::vector<glm::vec3> normals;
    std::vector<glm::vec3> colors;
    std::vector<glm::vec2> uvs;

    // Data structure for storing indices of vertices, the index has a type of 'unsigned int'
    std::vector<glm::uvec3> indicesOfVertices;

    // ID numbers of the VAO and VBOs associated with the geometry
    GLuint vao;
    GLuint vertexBuffer;
    GLuint normalBuffer;
    GLuint uvBuffer;
    GLuint colorBuffer;

    // ID number of the Element buffer object associated with the geometry
    GLuint ebo;

    // The ID of the texture on the object;
    GLint texture;

    // Draw mode for how OpenGL interprets primitives
    GLuint drawMode;
};

/**
 * The 'Shader' class defines all functions and members needed to compile
 * shaders, adjust uniforms in a shader file and link the program.
 */
class Shader {
public:
    GLuint programId;

    // Default constructor is not allowed
    Shader() = delete;

    // Constructor
    Shader(const char *vertexShaderSourceFilename,
           const char *fragmentShaderSourceFilename,
           const char *geometryShaderSourceFilename = nullptr) : programId(0) {

        // Load shader source from files
        std::string vertexSource = LoadSource(vertexShaderSourceFilename);
        std::string fragmentSource = LoadSource(fragmentShaderSourceFilename);

        // Geometry Shader is optional
        std::string geometrySource;
        if (geometryShaderSourceFilename) {
            geometrySource = LoadSource(geometryShaderSourceFilename);
        }

        // If source code is empty, exit the program as a failure
        if (vertexSource.empty()) {
            fprintf(stderr, "Vertex shader source file empty!\n");
            exit(EXIT_FAILURE);
        }
        if (fragmentSource.empty()) {
            fprintf(stderr, "Fragment shader source file empty!\n");
            exit(EXIT_FAILURE);
        }
        if (geometryShaderSourceFilename && geometrySource.empty()) {
            fprintf(stderr, "Geometry shader source file empty!\n");
            exit(EXIT_FAILURE);
        }

        // Compile shader source into shader objects
        GLuint vertex = CompileShader(GL_VERTEX_SHADER, vertexSource);
        GLuint geometry = 0;
        if (geometryShaderSourceFilename) {
            geometry = CompileShader(GL_GEOMETRY_SHADER, geometrySource);
        }
        GLuint fragment = CompileShader(GL_FRAGMENT_SHADER, fragmentSource);

        // Link shaderOfModel program
        LinkProgram(vertex, geometry, fragment);

        // Deallocate resources
        // Detach shaders
        glDetachShader(programId, vertex);
        if (geometry != 0) {
            glDetachShader(programId, geometry);
        }
        glDetachShader(programId, fragment);

        // Delete shaders
        glDeleteShader(vertex);
        if (geometry != 0) {
            glDeleteShader(geometry);
        }
        glDeleteShader(fragment);
    }

    // Use the shader program
    void use() {
        glUseProgram(programId);
    }

    /** A collection of GLSL uniform setters **/
    // GLSL uniform one int setter
    void setter_int(const std::string &variableName, GLint newValue) const {
        glUniform1i(glGetUniformLocation(programId, variableName.c_str()),
                    newValue);
    }

    // GLSL uniform one float setter
    void setter_float(const std::string &variableName, GLfloat newValue) const {
        glUniform1f(glGetUniformLocation(programId, variableName.c_str()),
                    newValue);
    }

    // GLSL uniform mat4x4(float) setter
    void setter_mat4f(const std::string &variableName, GLboolean transpose,
                      const GLfloat *newValue) const {
        glUniformMatrix4fv(
                glGetUniformLocation(programId, variableName.c_str()), 1,
                transpose, newValue);
    }

    // GLSL uniform vec3f setter
    void setter_vec3f(const std::string &variableName,
                      const glm::vec3 &newValue) const {
        glUniform3fv(glGetUniformLocation(programId, variableName.c_str()), 1,
                     &newValue[0]);
    }

private:
    static std::string LoadSource(const std::string &filename) {
        std::string source;
        if (!Utility::isRegularFile(filename)) {
            fprintf(stderr, "%s is not a valid file!\n", filename.c_str());
            exit(EXIT_FAILURE);
        }
        if (!Utility::isGlslFile(filename)) {
            fprintf(stderr, "%s is not a GLSL source file!\n",
                    filename.c_str());
            exit(EXIT_FAILURE);
        }
        if (!Utility::hasReadPermission(filename)) {
            fprintf(stderr,
                    "The current user has no READ permission for the file!\n");
            exit(EXIT_FAILURE);
        }
        std::ifstream input(filename.c_str());
        if (input) {
            std::copy(std::istreambuf_iterator<char>(input),
                      std::istreambuf_iterator<char>(),
                      back_inserter(source));
            input.close();
        } else {
            fprintf(stderr,
                    "ERROR: Could not load shader source from file %s\n",
                    filename.c_str());
            exit(EXIT_FAILURE);
        }
        return source;
    }

    static GLuint CompileShader(GLenum shaderType, const std::string &source) {

        // Obtain the ID of the shader which is allocated by OpenGL
        GLuint shaderObject = glCreateShader(shaderType);

        // Compile the source as a shader of the given type
        const GLchar *source_ptr = source.c_str();
        glShaderSource(shaderObject, 1, &source_ptr, nullptr);
        glCompileShader(shaderObject);

        // Check compile status
        GLint status;
        glGetShaderiv(shaderObject, GL_COMPILE_STATUS, &status);
        if (!status) {
            GLint length;
            glGetShaderiv(shaderObject, GL_INFO_LOG_LENGTH, &length);
            std::string info(static_cast<unsigned long>(length), ' ');
            glGetShaderInfoLog(shaderObject,
                               static_cast<GLsizei>(info.length()), &length,
                               &info[0]);
            fprintf(stderr, "ERROR compiling shader:\n\n%s\n%s\n", source_ptr,
                    info.c_str());
            // Quit if the shader failed to compile
            exit(EXIT_FAILURE);
        }
        return shaderObject;
    }

    void LinkProgram(GLuint vertexShader, GLuint geometryShader,
                     GLuint fragmentShader) {

        // Obtain the ID of the program which is allocated by OpenGL
        programId = glCreateProgram();

        // Attach provided shader objects to this program
        if (vertexShader) {
            glAttachShader(programId, vertexShader);
        }
        if (geometryShader) {
            glAttachShader(programId, geometryShader);
        }
        if (fragmentShader) {
            glAttachShader(programId, fragmentShader);
        }

        // Link the program with given attachments
        glLinkProgram(programId);

        // Check if the linking is successful
        GLint status;
        glGetProgramiv(programId, GL_LINK_STATUS, &status);
        if (!status) {
            GLint length;
            glGetProgramiv(programId, GL_INFO_LOG_LENGTH, &length);
            std::string info(static_cast<unsigned long>(length), ' ');
            glGetProgramInfoLog(programId, static_cast<GLsizei>(info.length()),
                                &length, &info[0]);
            fprintf(stderr, "ERROR linking shader program:\n%s\n",
                    info.c_str());
            // Quit if the linking is unsuccessful
            exit(EXIT_FAILURE);
        }
    }
};

/**
 * The 'RenderingEngine' defines all stuff about VAO, VBO, EBO and camera.
 */
class RenderingEngine {
public:
    // Constructor
    explicit RenderingEngine() {

        if (useCLion) {
            shaderOfModel = std::make_shared<Shader>(
                    "/Users/hshen/CLionProject/Assignment4/shaders/phong_vertex.glsl",
                    "/Users/hshen/CLionProject/Assignment4/shaders/phong_fragment.glsl");
            shaderOfProfile = std::make_shared<Shader>(
                    "/Users/hshen/CLionProject/Assignment4/shaders/vertex.glsl",
                    "/Users/hshen/CLionProject/Assignment4/shaders/fragment.glsl");
        } else {
            shaderOfModel = std::make_shared<Shader>(
                    "./shaders/phong_vertex.glsl",
                    "./shaders/phong_fragment.glsl");
            shaderOfProfile = std::make_shared<Shader>(
                    "./shaders/vertex.glsl",
                    "./shaders/fragment.glsl");
        }

        // Check if all shader programs are successfully initialized
        if (!shaderOfModel || !(shaderOfModel->programId)) {
            fprintf(stderr,
                    "Program could not initialize shaders of model, TERMINATING\n");
            exit(EXIT_FAILURE);
        }
        if (!shaderOfProfile || !(shaderOfProfile->programId)) {
            fprintf(stderr,
                    "Program could not initialize shaders of model, TERMINATING\n");
            exit(EXIT_FAILURE);
        }
    }

    // Destructor
    ~RenderingEngine() {
        // Delete the shader of the model
        glDeleteProgram(shaderOfModel->programId);
        glDeleteProgram(shaderOfProfile->programId);
        shaderOfModel = nullptr;
        shaderOfProfile = nullptr;
    }

    // Render each object
    static void RenderScene(const std::vector<Geometry> &objects) {

        // For perspective/parallel projection, if the user applied the
        // texture, we change the background to gray fully-opaque in order to
        // make sure the user can see the whole model clearly
        if (viewport != 1 && useTexture) {
            glClearColor(0.2f, 0.2f, 0.2f, 1.0f);
        }
            // Otherwise, refresh the screen by a black fully-opaque background
        else {
            glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
        }
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

        if (viewport == 1) {
            // Default implicit projection matrix is
            // glm::mat4 projection = glm::ortho(-1.0f, 1.0f,
            //                                  -1.0f,
            //                                  1.0f,
            //                                  -1.0f, 1.0f);
            shaderOfProfile->use();
        } else {
            // Set camera here (and we will have projection and view)
            int height = windowHeight;
            if (height == 0) {
                height = 1;
            }
            int width = windowWidth;
            GLfloat aspect = static_cast<GLfloat> (width) /
                             static_cast<GLfloat> (height);
            auto aspect_reciprocal = static_cast<GLfloat>(1.0 / aspect);
            glm::mat4 projection;

            if (isOrtho) {
                GLfloat multiplier = 2.0f;
                if (width <= height) {
                    projection = glm::ortho(-multiplier, multiplier,
                                            -multiplier * aspect_reciprocal,
                                            multiplier * aspect_reciprocal,
                                            -10.0f, 100.0f);
                } else {
                    projection = glm::ortho(-multiplier * aspect,
                                            multiplier * aspect, -multiplier,
                                            multiplier, -10.0f,
                                            100.0f);
                }
            } else {
                projection = glm::perspective(glm::radians(DEFAULT_FOV), aspect,
                                              2.0f, 100.0f);
            }

            // Set the lookAt function
            glm::mat4 view = glm::lookAt(eye, target, upVector);

            // Zoom in/out
            view = glm::scale(view, glm::vec3(zoom * 2, zoom * 2, zoom * 2));

            // Set uniforms in the shader of model
            shaderOfModel->use();
            shaderOfModel->setter_mat4f("projection", GL_FALSE,
                                        &projection[0][0]);
            shaderOfModel->setter_mat4f("view", GL_FALSE, &view[0][0]);

            // Set transformation of the model
            glm::mat4 model = glm::mat4(1.0f);

            // Rotate around z-axis
            model = glm::rotate(model, glm::radians(angleZ),
                                glm::vec3(0.0f, 0.0f, 1.0f));

            // Rotate around x-axis
            model = glm::rotate(model, glm::radians(angleX),
                                glm::vec3(1.0f, 0.0f, 0.0f));

            shaderOfModel->setter_mat4f("model", GL_FALSE, &model[0][0]);
        }

        // Draw every Geometry object from the 'objects' array.
        for (const Geometry &g : objects) {
            // Bind VAO
            glBindVertexArray(g.vao);
            glPointSize(pointSize);
            // Draw elements
            glDrawArrays(g.drawMode, 0,
                         static_cast<GLsizei>(g.vertices.size()));
            // Restore the state
            glBindVertexArray(0);
        }

        // Tell OpenGL no program will be used for rendering
        glUseProgram(0);

        // Ensure that VAO and VBOs are set up properly, there will be a message if any error occurs and program will abort.
        Utility::CheckGLErrors("VAO and VBOs are NOT set up properly");
    }

    // Create VAO and VBOs for objects
    static void assignBuffers(Geometry &geometry) {

        // Generate VAO for the object
        glGenVertexArrays(1, &geometry.vao);
        glBindVertexArray(geometry.vao);

        // Generate VBOs for the object (vertex)
        glGenBuffers(1, &geometry.vertexBuffer);
        glBindBuffer(GL_ARRAY_BUFFER, geometry.vertexBuffer);
        glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, (void *) nullptr);
        glEnableVertexAttribArray(0);

        // Generate VBOs for the object (color)
        glGenBuffers(1, &geometry.colorBuffer);
        glBindBuffer(GL_ARRAY_BUFFER, geometry.colorBuffer);
        glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 0, (void *) nullptr);
        glEnableVertexAttribArray(1);

        // Generate VBOs for the object (uv)
        glGenBuffers(1, &geometry.uvBuffer);
        glBindBuffer(GL_ARRAY_BUFFER, geometry.uvBuffer);
        glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 0, (void *) nullptr);
        glEnableVertexAttribArray(2);

        // Generate VBOs for the object (normal)
        glGenBuffers(1, &geometry.normalBuffer);
        glBindBuffer(GL_ARRAY_BUFFER, geometry.normalBuffer);
        glVertexAttribPointer(3, 3, GL_FLOAT, GL_FALSE, 0, (void *) nullptr);
        glEnableVertexAttribArray(3);

        glGenBuffers(1, &geometry.ebo);
        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, geometry.ebo);
    }

    // Bind and copy data from a Geometry instance to buffers
    static void setBufferData(Geometry &geometry) {

        // Send geometry to the GPU
        // Since it is a setter_int, we bind buffer again although we did this in RenderingEngine::assignBuffers.
        // Must be called whenever anything is updated about the object

        // glBindBuffer is to bind a named buffer object to a target
        // glBufferData is to allocate the space for a buffer object and copy the data stored in the specific address.

        glBindBuffer(GL_ARRAY_BUFFER, geometry.vertexBuffer);
        glBufferData(GL_ARRAY_BUFFER,
                     sizeof(glm::vec3) * geometry.vertices.size(),
                     geometry.vertices.data(),
                     GL_STATIC_DRAW);

        glBindBuffer(GL_ARRAY_BUFFER, geometry.colorBuffer);
        glBufferData(GL_ARRAY_BUFFER,
                     sizeof(glm::vec3) * geometry.colors.size(),
                     geometry.colors.data(),
                     GL_STATIC_DRAW);

        glBindBuffer(GL_ARRAY_BUFFER, geometry.uvBuffer);
        glBufferData(GL_ARRAY_BUFFER, sizeof(glm::vec2) * geometry.uvs.size(),
                     geometry.uvs.data(), GL_STATIC_DRAW);

        glBindBuffer(GL_ARRAY_BUFFER, geometry.normalBuffer);
        glBufferData(GL_ARRAY_BUFFER,
                     sizeof(glm::vec3) * geometry.normals.size(),
                     geometry.normals.data(),
                     GL_STATIC_DRAW);

        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, geometry.ebo);
        glBufferData(GL_ELEMENT_ARRAY_BUFFER,
                     sizeof(glm::ivec3) * geometry.indicesOfVertices.size(),
                     geometry.indicesOfVertices.data(), GL_STATIC_DRAW);
    }

    // Delete buffers in a Geometry instance
    static void deleteBufferData(Geometry &geometry) {
        glDeleteBuffers(1, &geometry.vertexBuffer);
        glDeleteBuffers(1, &geometry.normalBuffer);
        glDeleteBuffers(1, &geometry.colorBuffer);
        glDeleteBuffers(1, &geometry.uvBuffer);
        glDeleteBuffers(1, &geometry.ebo);
        glDeleteVertexArrays(1, &geometry.vao);
    }
};

/**
 * The class 'Scene' defines a scene where all the models are placed.
 */
class Scene {
public:

    // No default constructor allowed
    Scene() = delete;

    // Constructor
    explicit Scene(std::shared_ptr<RenderingEngine> renderer) : renderer(
            std::move(renderer)) {

        // Initialization of the light and the material in the scene
        shaderOfModel->use();
        shaderOfModel->setter_vec3f("lightDirection", lightDirection);

        // Set light properties
        lightAmbientStrength = glm::vec3(0.25f);
        lightAmbient = lightColor * lightAmbientStrength;
        lightDiffuse = lightColor * glm::vec3(0.5f);
        lightSpecularStrength = {0.5f, 0.5f, 0.5f};
        shaderOfModel->setter_vec3f("lightAmbient", lightAmbient);
        shaderOfModel->setter_vec3f("lightDiffuse", lightDiffuse);
        shaderOfModel->setter_vec3f("lightSpecular", lightSpecularStrength);

        // Material properties
        materialAmbient = {1.0f, 0.54f, 0.35f};
        materialDiffuse = {1.0f, 0.54f, 0.35f};
        materialSpecular = WHITE;
        shininess = 32.0f;

        shaderOfModel->setter_vec3f("materialAmbient", materialAmbient);
        shaderOfModel->setter_vec3f("materialDiffuse", materialDiffuse);
        shaderOfModel->setter_vec3f("materialSpecular", materialSpecular);
        shaderOfModel->setter_float("shininess", shininess);

        // Generate the texture
        generateCheckerboard();
        // Bind the texture ID to the fragment shader
        bindTexture();

        // Initialization of objects in the scene
        drawScene();
    }

    // Destructor
    ~Scene() {
        // Delete buffer data of all objects in scene
        cleanScene();
        // Empty the container
        cleanObjects();
    }

    // Send Geometry instance to the renderer (Switch scene here)
    void displayScene() {

        if (viewport == 1) {
            renderer->RenderScene(pointsList);
        } else {

            // If the profile has been modified, we need to re-generate
            // objectsList
            if (isModified) {

                unsigned int segments{};
                if (!useTexture) {
                    if (useCLion) {
                        segments = 100;
                    } else {
                        segments = 1000;
                    }
                } else {
                    segments = 100;
                }

                std::vector<glm::vec3> curvePoints;
                std::vector<std::tuple<glm::vec3, glm::vec3, glm::vec2> > temp;

                // Use low number of segments if the texture is applied
                // otherwise use high number of segments

                // If no texture is applied, we can lathe it directly and
                // don't need to regenerate the points on the curve
                if (!useTexture) {
                    curvePoints = pointsList.at(4).vertices;
                    curvePoints.emplace_back(
                            pointsList.at(1).vertices.back());
                }
                    // Otherwise, re-generate the curve with low segments
                else {
                    if (method == 1) {
                        curvePoints = deCasteljau(
                                pointsList.at(0).vertices, segments);
                        curvePoints.emplace_back(
                                pointsList.at(0).vertices.back());
                    } else {
                        curvePoints = pointsList.at(0).vertices;
                        curvePoints.pop_back();
                        while (!curvePoints.empty() &&
                               curvePoints.size() < segments) {
                            chasingGame(curvePoints);
                        }
                        curvePoints.emplace_back(
                                pointsList.at(0).vertices.back());
                    }
                }
                temp = lathe(curvePoints, segments);

                // Delete all old data
                std::vector<glm::vec3>().swap(objectsList.at(0).vertices);
                std::vector<glm::vec3>().swap(objectsList.at(0).colors);
                std::vector<glm::vec3>().swap(objectsList.at(0).normals);
                std::vector<glm::vec2>().swap(objectsList.at(0).uvs);

                // Write new data
                objectsList.at(0).vertices.resize(temp.size());
                objectsList.at(0).colors.resize(temp.size());
                objectsList.at(0).normals.resize(temp.size());
                objectsList.at(0).uvs.resize(temp.size());

                {
                    omp_set_num_threads(numberOfThreads);
                    #pragma omp parallel for
                    for (size_t i = 0; i < temp.size(); ++i) {
                        objectsList.at(0).vertices.at(i) = std::get<0>(
                                temp.at(i));
                        objectsList.at(0).normals.at(i) = std::get<1>(
                                temp.at(i));
                        objectsList.at(0).uvs.at(i) = std::get<2>(temp.at(i));
                        objectsList.at(0).colors.at(i) = WHITE;
                    }
                }

                // Delete old VAO, VBO
                RenderingEngine::deleteBufferData(objectsList.at(0));
                // Generate new VAO, VBO
                RenderingEngine::assignBuffers(objectsList.at(0));
                RenderingEngine::setBufferData(objectsList.at(0));

                // Reset the flag
                isModified = false;
            }
            renderer->RenderScene(objectsList);
        }
    }

    // Draw the scene
    void drawScene() {

        /** Model templates are not used if we load data from external files **/
        if (!pointsList.empty()) {

            // Generate VAO, VBO for the first two elements of pointsList
            RenderingEngine::assignBuffers(pointsList.at(0));
            RenderingEngine::setBufferData(pointsList.at(0));
            RenderingEngine::assignBuffers(pointsList.at(1));
            RenderingEngine::setBufferData(pointsList.at(1));

            // Draw the boundaries
            // draw the y-axis indicator
            Geometry yAxisIndicator;
            yAxisIndicator.vertices.emplace_back(0.0f, 1.0f, 0.0f);
            yAxisIndicator.vertices.emplace_back(0.0f, -0.9f, 0.0f);
            yAxisIndicator.colors.resize(yAxisIndicator.vertices.size());
            // Give all of them gray color
            std::fill(yAxisIndicator.colors.begin(),
                      yAxisIndicator.colors.end(),
                      GRAY);
            yAxisIndicator.drawMode = GL_LINES;
            RenderingEngine::assignBuffers(yAxisIndicator);
            RenderingEngine::setBufferData(yAxisIndicator);

            // draw the bottom line
            Geometry bottomLine;
            bottomLine.vertices.emplace_back(-1.0f, -0.9f, 0.0f);
            bottomLine.vertices.emplace_back(1.0f, -0.9f, 0.0f);
            bottomLine.colors.resize(bottomLine.vertices.size());
            // Give all of them gray color
            std::fill(bottomLine.colors.begin(),
                      bottomLine.colors.end(),
                      GRAY);
            bottomLine.drawMode = GL_LINES;
            RenderingEngine::assignBuffers(bottomLine);
            RenderingEngine::setBufferData(bottomLine);

            pointsList.emplace_back(yAxisIndicator);
            pointsList.emplace_back(bottomLine);

            unsigned int segments{};
            if (useCLion) {
                segments = 100;
            } else {
                segments = 1000;
            }

            if (method == 1) {
                // Generate all points for Bezier curve
                auto bezierCurvePoints = deCasteljau(pointsList.at(0).vertices,
                                                     segments);
                // Generate the line strip along the points of the curve
                Geometry bezierCurve;
                bezierCurve.vertices = bezierCurvePoints;
                bezierCurve.colors.resize(bezierCurvePoints.size());
                std::fill(bezierCurve.colors.begin(),
                          bezierCurve.colors.end(),
                          WHITE);
                bezierCurve.drawMode = GL_LINE_STRIP;
                RenderingEngine::assignBuffers(bezierCurve);
                RenderingEngine::setBufferData(bezierCurve);
                pointsList.emplace_back(bezierCurve);
            } else {
                // Generate the line strip along the points in the B-spline curve
                Geometry bsplineCurve;
                bsplineCurve.vertices = pointsList.at(0).vertices;
                // The last point should be ignored here
                bsplineCurve.vertices.pop_back();
                // Use 'the chasing game' to generate points in the curve
                // when there is at least 1 point
                while (!bsplineCurve.vertices.empty()
                       && bsplineCurve.vertices.size() <
                          bspline_segment_threshold) {
                    chasingGame(bsplineCurve.vertices);
                }
                // Append the last point
                bsplineCurve.vertices.emplace_back(
                        pointsList.at(0).vertices.back());
                // Give all of them white color
                bsplineCurve.colors.resize(bsplineCurve.vertices.size());
                std::fill(bsplineCurve.colors.begin(),
                          bsplineCurve.colors.end(),
                          WHITE);

                bsplineCurve.drawMode = GL_LINE_STRIP;
                RenderingEngine::assignBuffers(bsplineCurve);
                RenderingEngine::setBufferData(bsplineCurve);
                pointsList.emplace_back(bsplineCurve);
            }
        }

        /** Model template 1: Parametric Bezier Curve **/
        else if (method == 1) {

            // draw the profile line
            Geometry controlLines;
            controlLines.vertices.emplace_back(-0.211432, 0.711736, 0.0f);
            controlLines.vertices.emplace_back(-0.103967, 0.32934, 0.0f);
            controlLines.vertices.emplace_back(-0.192378, -0.0599479, 0.0f);
            controlLines.vertices.emplace_back(-0.45145, -0.0750781, 0.0f);
            controlLines.vertices.emplace_back(-0.7, -0.4, 0.0f);
            controlLines.vertices.emplace_back(-0.252387, -0.9, 0.0f);

            // Add the center of the bottom of the pottery which is not changed
            controlLines.vertices.emplace_back(0.0, -0.9f, 0.0f);

            // Make sure all vertices layout along the y-axis
            __gnu_parallel::sort(controlLines.vertices.begin(),
                      controlLines.vertices.end(),
                      comparator);

            // Set the profile line blue
            controlLines.colors.resize(controlLines.vertices.size());
            std::fill(controlLines.colors.begin(),
                      controlLines.colors.end(),
                      BLUE);
            controlLines.drawMode = GL_LINE_STRIP;
            RenderingEngine::assignBuffers(controlLines);
            RenderingEngine::setBufferData(controlLines);

            // draw all control points
            Geometry controlPoints;
            controlPoints.vertices.resize(controlLines.vertices.size());
            controlPoints.colors.resize(controlPoints.vertices.size());

            {
                omp_set_num_threads(numberOfThreads);
                #pragma omp parallel for
                for (size_t i = 0; i < controlLines.vertices.size(); ++i) {
                    // -1.0f will make control points show on the front of the control lines
                    controlPoints.vertices.at(i) = glm::vec3(
                            controlLines.vertices.at(i).x,
                            controlLines.vertices.at(i).y,
                            -1.0f);
                    // Give all control point yellow color except the last one
                    controlPoints.colors.at(i) = YELLOW;
                }
            }
            controlPoints.colors.back() = RED;

            controlPoints.drawMode = GL_POINTS;
            RenderingEngine::assignBuffers(controlPoints);
            RenderingEngine::setBufferData(controlPoints);

            unsigned int segments{};
            if (useCLion) {
                segments = 100;
            } else {
                segments = 1000;
            }

            // Generate all points for Bezier curve
            auto bezierCurvePoints = deCasteljau(controlLines.vertices,
                                                 segments);
            // Append the last point
            bezierCurvePoints.emplace_back(controlLines.vertices.back());
            // Generate the line strip along the points of the curve
            Geometry bezierCurve;
            bezierCurve.vertices = bezierCurvePoints;
            // Give all of them white color
            bezierCurve.colors.resize(bezierCurvePoints.size());
            std::fill(bezierCurve.colors.begin(),
                      bezierCurve.colors.end(),
                      WHITE);
            bezierCurve.drawMode = GL_LINE_STRIP;
            RenderingEngine::assignBuffers(bezierCurve);
            RenderingEngine::setBufferData(bezierCurve);

            // Draw the boundaries
            // draw the y-axis indicator
            Geometry yAxisIndicator;
            yAxisIndicator.vertices.emplace_back(0.0f, 1.0f, 0.0f);
            yAxisIndicator.vertices.emplace_back(0.0f, -0.9f, 0.0f);
            yAxisIndicator.colors.resize(yAxisIndicator.vertices.size());
            // Give all of them gray color
            std::fill(yAxisIndicator.colors.begin(),
                      yAxisIndicator.colors.end(),
                      GRAY);
            yAxisIndicator.drawMode = GL_LINES;
            RenderingEngine::assignBuffers(yAxisIndicator);
            RenderingEngine::setBufferData(yAxisIndicator);

            // draw the bottom line
            Geometry bottomLine;
            bottomLine.vertices.emplace_back(-1.0f, -0.9f, 0.0f);
            bottomLine.vertices.emplace_back(1.0f, -0.9f, 0.0f);
            bottomLine.colors.resize(bottomLine.vertices.size());
            // Give all of them gray color
            std::fill(bottomLine.colors.begin(),
                      bottomLine.colors.end(),
                      GRAY);
            bottomLine.drawMode = GL_LINES;
            RenderingEngine::assignBuffers(bottomLine);
            RenderingEngine::setBufferData(bottomLine);

            pointsList.emplace_back(controlLines);
            pointsList.emplace_back(controlPoints);
            pointsList.emplace_back(yAxisIndicator);
            pointsList.emplace_back(bottomLine);
            pointsList.emplace_back(bezierCurve);
        }

        /** Model template 2: B-Spline subdivision curve **/
        else {

            // draw the profile line
            Geometry polygonOfPoints;
            polygonOfPoints.vertices.emplace_back(-0.31316, 0.895842,
                                                  0.0f);
            polygonOfPoints.vertices.emplace_back(-0.211432, 0.711736, 0.0f);
            polygonOfPoints.vertices.emplace_back(-0.839054, 0.292127, 0.0f);
            polygonOfPoints.vertices.emplace_back(-0.254722, -0.0333854, 0.0f);
            polygonOfPoints.vertices.emplace_back(-0.418403, -0.298516, 0.0f);
            polygonOfPoints.vertices.emplace_back(-0.20428, -0.58349, 0.0f);
            polygonOfPoints.vertices.emplace_back(-0.252387, -0.9, 0.0f);

            // Add the center of the bottom of the pottery which is not changed
            polygonOfPoints.vertices.emplace_back(0.0, -0.9f, 0.0f);

            // Make sure all vertices layout along the y-axis
            __gnu_parallel::sort(polygonOfPoints.vertices.begin(),
                      polygonOfPoints.vertices.end(),
                      comparator);

            // Set the profile line blue
            polygonOfPoints.colors.resize(polygonOfPoints.vertices.size());
            std::fill(polygonOfPoints.colors.begin(),
                      polygonOfPoints.colors.end(),
                      BLUE);
            polygonOfPoints.drawMode = GL_LINE_STRIP;
            RenderingEngine::assignBuffers(polygonOfPoints);
            RenderingEngine::setBufferData(polygonOfPoints);

            // draw all points before subdivisions
            Geometry points;
            points.vertices.resize(polygonOfPoints.vertices.size());
            points.colors.resize(points.vertices.size());
            {
                omp_set_num_threads(numberOfThreads);
                #pragma omp parallel for
                for (size_t i = 0; i < polygonOfPoints.vertices.size(); ++i) {
                    points.vertices.at(i) = glm::vec3(
                            polygonOfPoints.vertices.at(i).x,
                            polygonOfPoints.vertices.at(i).y,
                            -1.0f); // -1.0f will make control points show on the front of the control lines
                    // give all these points a yellow color
                    points.colors.at(i) = YELLOW;
                }
            }
            // Give the center of the bottom of the pottery a red color
            points.colors.back() = RED;
            points.drawMode = GL_POINTS;
            RenderingEngine::assignBuffers(points);
            RenderingEngine::setBufferData(points);

            // Generate the line strip along the points in the B-spline curve
            Geometry bsplineCurve;
            bsplineCurve.vertices = points.vertices;
            // The last point should be ignored here
            bsplineCurve.vertices.pop_back();
            // Use 'the chasing game' to generate points in the curve
            while (!bsplineCurve.vertices.empty()
                   && bsplineCurve.vertices.size() <
                      bspline_segment_threshold) {
                chasingGame(bsplineCurve.vertices);
            }
            // Append the last point
            bsplineCurve.vertices.emplace_back(points.vertices.back());
            // Give all of them white color
            bsplineCurve.colors.resize(bsplineCurve.vertices.size());
            std::fill(bsplineCurve.colors.begin(),
                      bsplineCurve.colors.end(),
                      WHITE);
            bsplineCurve.drawMode = GL_LINE_STRIP;
            RenderingEngine::assignBuffers(bsplineCurve);
            RenderingEngine::setBufferData(bsplineCurve);

            // Draw the boundaries
            // draw the y-axis indicator
            Geometry yAxisIndicator;
            yAxisIndicator.vertices.emplace_back(0.0f, 1.0f, 0.0f);
            yAxisIndicator.vertices.emplace_back(0.0f, -0.9f, 0.0f);
            yAxisIndicator.colors.resize(yAxisIndicator.vertices.size());
            // Give all of them gray color
            std::fill(yAxisIndicator.colors.begin(),
                      yAxisIndicator.colors.end(),
                      GRAY);
            yAxisIndicator.drawMode = GL_LINES;
            RenderingEngine::assignBuffers(yAxisIndicator);
            RenderingEngine::setBufferData(yAxisIndicator);

            // draw the bottom line
            Geometry bottomLine;
            bottomLine.vertices.emplace_back(-1.0f, -0.9f, 0.0f);
            bottomLine.vertices.emplace_back(1.0f, -0.9f, 0.0f);
            bottomLine.colors.resize(bottomLine.vertices.size());
            // Give all of them gray color
            std::fill(bottomLine.colors.begin(),
                      bottomLine.colors.end(),
                      GRAY);
            bottomLine.drawMode = GL_LINES;
            RenderingEngine::assignBuffers(bottomLine);
            RenderingEngine::setBufferData(bottomLine);

            pointsList.emplace_back(polygonOfPoints);
            pointsList.emplace_back(points);
            pointsList.emplace_back(yAxisIndicator);
            pointsList.emplace_back(bottomLine);
            pointsList.emplace_back(bsplineCurve);
        }

        /** Create the corresponding 3D object **/
        // draw the pottery
        // Since it is the first time to draw the pottery,
        // no texture is applied
        unsigned int segments{};
        if (useCLion) {
            segments = 100;
        } else {
            segments = 1000;
        }

        Geometry model;
        auto tempVerticesList = pointsList.at(4).vertices;
        tempVerticesList.emplace_back(pointsList.at(1).vertices.back());
        auto temp = lathe(tempVerticesList, segments);
        model.vertices.resize(temp.size());
        model.colors.resize(temp.size());
        model.normals.resize(temp.size());
        model.uvs.resize(temp.size());

        {
            omp_set_num_threads(numberOfThreads);
            #pragma omp parallel for
            for (size_t i = 0; i < temp.size(); ++i) {
                model.vertices.at(i) = std::get<0>(temp.at(i));
                model.normals.at(i) = std::get<1>(temp.at(i));
                model.uvs.at(i) = std::get<2>(temp.at(i));
                model.colors.at(i) = WHITE;
            }
        }

        model.drawMode = GL_TRIANGLES;
        RenderingEngine::assignBuffers(model);
        RenderingEngine::setBufferData(model);
        objectsList.emplace_back(model);
    }

    // Clean the Scene
    void cleanScene() {
        for (auto &i : pointsList) {
            RenderingEngine::deleteBufferData(i);
        }
        for (auto &i : objectsList) {
            RenderingEngine::deleteBufferData(i);
        }
    }

    // Clean objects in the container 'objects'
    void cleanObjects() {
        std::vector<Geometry>().swap(objectsList);
        std::vector<Geometry>().swap(pointsList);
    }
private:
    std::shared_ptr<RenderingEngine> renderer;
};

/**
 * The 'Program' class controls the main logic of the program.
 */
class Program {
public:
    // Constructor
    Program() {
        setupRC();
    }

    // Destructor
    ~Program() {
        destroyTexture();
        glfwDestroyWindow(window);
        glfwTerminate();
    }

    // Creates the rendering engine and the scene and does the main draw loop
    void start() {

        // Initialize the rendering engine and our shaders will be compiled
        renderingEngine = std::make_shared<RenderingEngine>();

        // Initialize the scene for drawing objects
        scene = std::make_shared<Scene>(renderingEngine);

        // Enter the main render loop
        while (!glfwWindowShouldClose(window)) {
            // Render objects
            scene->displayScene();
            glfwSwapBuffers(window);
            glfwPollEvents();
        }
    }

    // Initializes the render context
    void setupRC() {
        // Set the custom error callback function before initialization
        // Errors will be printed to the console
        glfwSetErrorCallback(errorCallback);

        // Initialize the GLFW windowing system, exit if it fails to initialize
        if (!glfwInit()) {
            fprintf(stderr, "ERROR: GLFW failed to initialize, TERMINATING\n");
            exit(EXIT_FAILURE);
        }

        // Create a window with an OpenGL minimum version 4.1 core profile context
        glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);
        glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 1);
        glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);
#ifdef __APPLE__
        glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
#endif
        // Use 4xMSAA in MS239
        if (!useCLion) {
            glfwWindowHint(GLFW_SAMPLES, 4);
        }
        // Make the window resizable
        glfwWindowHint(GLFW_RESIZABLE, GL_TRUE);

        const auto vidmode = glfwGetVideoMode(glfwGetPrimaryMonitor());
        windowWidth = vidmode->width;
        windowHeight = vidmode->height;

        window = glfwCreateWindow(
                windowWidth,
                windowHeight,
                u8"CPSC453 Fall2019 Assignment4",
                nullptr,
                nullptr);
        if (!window) {
            fprintf(stderr,
                    "Program failed to create GLFW window, TERMINATING\n");
            glfwTerminate();
            exit(EXIT_FAILURE);
        }

        // Set the size of the window as 1/4 of the screen
        glfwSetWindowSize(window, windowWidth / 2, windowHeight / 2);

        // Set the custom function that tracks key presses
        glfwSetKeyCallback(window, keyCallback);

        // Set the callback executed when the window is closed
        glfwSetWindowCloseCallback(window, windowCloseCallback);

        // Set the callback executed when the cursor of the mouse moves
        glfwSetCursorPosCallback(window, mouseCursorCallback);

        // Set the call executed when the user presses the mouse's button
        glfwSetMouseButtonCallback(window, mouseButtonCallback);

        // Set the framebuffer resize callback for the specified window.
        glfwSetFramebufferSizeCallback(window, frameBufferSizeCallback);

        // We restrict the aspect ratio by using GLFW
        // thus the aspect ratio will not change when the user re-sizes the window
        glfwSetWindowAspectRatio(window, windowWidth,
                                 windowHeight);

        // Set the current OpenGL context
        glfwMakeContextCurrent(window);

        // Initialize GLAD (finds appropriate OpenGL configuration for the system)
        if (!gladLoadGL()) {
            fprintf(stderr, "GLAD failed to initialize\n");
            exit(EXIT_FAILURE);
        }

        // Enable v-sync
        glfwSwapInterval(1);

        // Define the viewport dimensions
        glViewport(0, 0, windowWidth, windowHeight);

        // Disable multi-sample
        glEnable(GL_MULTISAMPLE);

        // Enable line and polygon antialiasing
        glEnable(GL_LINE_SMOOTH);
        glHint(GL_LINE_SMOOTH_HINT, GL_NICEST);
        glEnable(GL_POLYGON_SMOOTH);
        glHint(GL_POLYGON_SMOOTH_HINT, GL_NICEST);

        // Enable Z-Buffer
        glEnable(GL_DEPTH_TEST);

        // Accept fragment if it is closer to the camera than the former one
        glDepthFunc(GL_LESS);

        // Make sure Counter-Clockwise is the direction of the front face
        glFrontFace(GL_CCW);
    }

private:
    GLFWwindow *window = nullptr;
    std::shared_ptr<RenderingEngine> renderingEngine;
    std::shared_ptr<Scene> scene;
};

/** The definitions of all functions defined outside namespaces, classes and functions**/

// The callback executed when the size of the frame buffer changes
void frameBufferSizeCallback(GLFWwindow *window, int width, int height) {
    glViewport(0, 0, width, height);
}

// The callback executed when an action is taken on a mouse button
void mouseButtonCallback(GLFWwindow *window, int key, int action, int mods) {

    // When the user is in ZOOM mode of perspective/parallel projection:
    // Press mouse left button + drag forward/backward: zoom in/out
    //
    // When the user is in ROTATION mode of perspective/parallel projection:
    // Press mouse left button  + drag left/right: rotate left/right along z-axis
    // Press mouse right button + drag left/right: rotate up/down along x-axis
    //
    // When the user selects a point in the profile projection
    // Press mouse left button + drag: move the point
    //
    // When the user is in INSERT mode of profile projection
    // Press mouse left button: insert a point at the pixel clicked
    //
    // When the user selected a point mode of profile projection

    if (key == GLFW_MOUSE_BUTTON_LEFT) {
        if (action == GLFW_PRESS) {
            // Update 'isLeftButtonPressed'
            isLeftButtonPressed = !isLeftButtonPressed;

            // Select a point when
            // 1. current viewport is 1
            // 2. no selected points
            if (viewport == 1 && indexOfPointSelected == -1) {
                selectAPoint(window);
            }

            // Insert a point when
            // 1. current viewport is 1
            // 3. in the INSERT mode
            // 4. if a point is selected, it will be de-selected before the insertion
            if (viewport == 1 && insertMode) {
                if (indexOfPointSelected != -1) {
                    deselectAPoint();
                }
                insertAPoint(window);
            }
        }
            // Update 'isLeftButtonPressed'
        else if (action == GLFW_RELEASE) {
            isLeftButtonPressed = false;
        }
    } else if (key == GLFW_MOUSE_BUTTON_RIGHT) {
        if (action == GLFW_PRESS) {
            // Update 'isRightButtonPressed'
            isRightButtonPressed = !isRightButtonPressed;

            // Deselect all points selected when
            // 1. Current viewport is 1
            // 2. There exists a point selected
            // 3. The user does a mouse-right-click
            if (viewport == 1 && indexOfPointSelected != -1) {
                deselectAPoint();
            }
        }
        // Update 'isRightButtonPressed'
        else if (action == GLFW_RELEASE) {
            isRightButtonPressed = false;
        }
    }
}

// The callback executed when a cursor moves
void mouseCursorCallback(GLFWwindow *window, double x, double y) {

    // Move a point when
    // 1. Rendering mode is 1
    // 2. There exists a point selected
    // 3. The user is not inserting a point
    // 4. The user is pressing the mouse-left-button
    if (viewport == 1 && indexOfPointSelected != -1 &&
        isLeftButtonPressed && !insertMode) {
        moveAPoint(window, x, y);
    }

    // When current viewport != 1, do the rotation/zooming
    if (viewport != 1) {

        double offset_x = 0.0;
        double offset_y = 0.0;
        static double last_x = 0.0;
        static double last_y = 0.0;

        if (firstMoveAfterSwitch) {
            firstMoveAfterSwitch = false;
        } else {
            offset_x = x - last_x;
            offset_y = y - last_y;
        }

        last_x = x;
        last_y = y;
        Utility::clamp<double>(offset_x, -MAXIMAL_OFFSET, MAXIMAL_OFFSET);
        Utility::clamp<double>(offset_y, -MAXIMAL_OFFSET, MAXIMAL_OFFSET);

        // Movement for rotation mode
        if (!zoomMode) {
            // Rotation along z-axis
            if (isLeftButtonPressed) {
                angleZ += 0.5f * static_cast<float>(offset_x);
            }
            // Rotation along x-axis
            if (isRightButtonPressed) {
                angleX += 0.5f * static_cast<float>(offset_y);
            }
        } else if (isLeftButtonPressed) {
            zoom -= 0.01f * static_cast<float>(offset_y);
            // Set a lower bound for zoom make sure the model is always visible in the viewport
            if (zoom < MINIMAL_ZOOM) {
                zoom = MINIMAL_ZOOM;
            }
        }
    }
}

// The callback executed when the window closes
void windowCloseCallback(GLFWwindow *window) {
    fprintf(stdout, "Exit the program...\n");
}

// The callback executed when an action is taken on a key
void
keyCallback(GLFWwindow *window, int key, int scancode, int action, int mods) {

    // ESC: Exit the program
    // H:   Show the helping information
    // Z:   Switch between zoom/rotation in perspective/parallel projection
    // Q:   Print the information of current context
    // R:   Reset the camera and the light direction in perspective/parallel projection
    // T:   Switch between not using texture/applying the procedural texture in perspective/parallel projection
    // 1:   Switch to the viewport of the profile
    // 2:   Switch to the viewport of the perspective projection
    // 3:   Switch to the viewport of the parallel projection
    //
    // Suppose that the direction of the light is (x, y, z), then
    // 4.   for +x
    // 5.   for -x
    // 6.   for +y
    // 7.   for -y
    // 8.   for +z
    // 9.   for -z
    //
    // I:   Insert a point
    // D:   Delete the selected point
    // M:   Move a point
    // S:   Save the current method to generate the curve and
    //      the position of all control points if the curve is a Bezier curve or
    //      the position of all points before subdivision if the curve is a b-spline
    //      to a file named with current time and .dat as its suffix

    if (key == GLFW_KEY_ESCAPE && action == GLFW_PRESS) {
        fprintf(stdout, "Exit the program...\n");
        glfwSetWindowShouldClose(window, GL_TRUE);
    } else if (key == GLFW_KEY_Z && action == GLFW_PRESS) {
        // Press 'Z' to switch between zoom/rotation mode when viewport != 1
        if (viewport != 1) {
            isLeftButtonPressed = false;
            isRightButtonPressed = false;
            firstMoveAfterSwitch = true;
            zoomMode = !zoomMode;
        }
    } else if (key == GLFW_KEY_Q && action == GLFW_PRESS) {
        fprintf(stdout, "%s", DELIMITER);
        queryBasicInformation(window);
        fprintf(stdout, "%s", DELIMITER);
    } else if (key == GLFW_KEY_R && action == GLFW_PRESS) {
        // Press 'R' to reset all states when viewport != 1
        if (viewport != 1) {
            // Reset the arguments of the camera
            zoomMode = false;
            isOrtho = false;
            isLeftButtonPressed = false;
            isRightButtonPressed = false;
            firstMoveAfterSwitch = true;

            angleZ = DEFAULT_ANGLE;
            angleX = DEFAULT_ANGLE;
            zoom = DEFAULT_ZOOM;

            // Reset the light direction
            lightDirection = DEFAULT_LIGHT_DIRECTION;
            shaderOfModel->use();
            shaderOfModel->setter_vec3f("lightDirection", lightDirection);
        }
    } else if (key == GLFW_KEY_1 && action == GLFW_PRESS) {
        // Profile
        viewport = 1;
        isOrtho = false;
    } else if (key == GLFW_KEY_2 && action == GLFW_PRESS) {
        // Phong shading perspective
        viewport = 2;
        isOrtho = false;
        firstMoveAfterSwitch = true;
    } else if (key == GLFW_KEY_3 && action == GLFW_PRESS) {
        // Phong shading ortho
        viewport = 3;
        isOrtho = true;
        firstMoveAfterSwitch = true;
    } else if (key == GLFW_KEY_I && action == GLFW_PRESS) {
        if (viewport == 1) {
            insertMode = true;
            fprintf(stdout, "Enter INSERT mode\n");
            fprintf(stdout, "Insert a point by clicking a pixel ...\n");
        }
    } else if (key == GLFW_KEY_M && action == GLFW_PRESS) {
        if (viewport == 1) {
            fprintf(stdout,"Click the pixel as the destination of the selected point after movement ...\n");
        }
    } else if (key == GLFW_KEY_D && action == GLFW_PRESS) {
        // Delete the selected point when
        // 1. Current viewport is 1
        // 2. A point is selected
        if (viewport == 1) {
            // If no points selected, prompt a message and do nothing
            if (indexOfPointSelected == -1) {
                fprintf(stdout, "No points selected!\n");
                return;
            }
            deleteSelectedPoint();
        }
    } else if (key == GLFW_KEY_S && action == GLFW_PRESS) {
        serialize();
    } else if (key == GLFW_KEY_4 && action == GLFW_PRESS) {
        lightDirection.x += DEFAULT_LIGHT_DIRECTION_INCREMENT;
        // update the uniform
        shaderOfModel->use();
        shaderOfModel->setter_vec3f("lightDirection", lightDirection);
        // print the update info
        printLightDirection();
    } else if (key == GLFW_KEY_5 && action == GLFW_PRESS) {
        lightDirection.x -= DEFAULT_LIGHT_DIRECTION_INCREMENT;
        // update the uniform
        shaderOfModel->use();
        shaderOfModel->setter_vec3f("lightDirection", lightDirection);
        // print the update info
        printLightDirection();
    } else if (key == GLFW_KEY_6 && action == GLFW_PRESS) {
        lightDirection.y += DEFAULT_LIGHT_DIRECTION_INCREMENT;
        // update the uniform
        shaderOfModel->use();
        shaderOfModel->setter_vec3f("lightDirection", lightDirection);
        // print the update info
        printLightDirection();
    } else if (key == GLFW_KEY_7 && action == GLFW_PRESS) {
        lightDirection.y -= DEFAULT_LIGHT_DIRECTION_INCREMENT;
        // update the uniform
        shaderOfModel->use();
        shaderOfModel->setter_vec3f("lightDirection", lightDirection);
        // print the update info
        printLightDirection();
    } else if (key == GLFW_KEY_8 && action == GLFW_PRESS) {
        lightDirection.z += DEFAULT_LIGHT_DIRECTION_INCREMENT;
        // update the uniform
        shaderOfModel->use();
        shaderOfModel->setter_vec3f("lightDirection", lightDirection);
        // print the update info
        printLightDirection();
    } else if (key == GLFW_KEY_9 && action == GLFW_PRESS) {
        lightDirection.z -= DEFAULT_LIGHT_DIRECTION_INCREMENT;
        // update the uniform
        shaderOfModel->use();
        shaderOfModel->setter_vec3f("lightDirection", lightDirection);
        // print the update info
        printLightDirection();
    } else if (key == GLFW_KEY_T && action == GLFW_PRESS) {
        if (viewport != 1) {
            useTexture = !useTexture;
            if (useTexture) {
                fprintf(stdout, "Generating texture...\n");
            } else {
                fprintf(stdout, "Removing texture...\n");
            }
            // Delete all old data
            std::vector<glm::vec3>().swap(objectsList.at(0).vertices);
            std::vector<glm::vec3>().swap(objectsList.at(0).colors);
            std::vector<glm::vec3>().swap(objectsList.at(0).normals);
            std::vector<glm::vec2>().swap(objectsList.at(0).uvs);
            // Define the new number of segments
            unsigned int segments{};
            if (!useTexture) {
                if (useCLion) {
                    segments = 100;
                } else {
                    segments = 1000;
                }
            } else {
                segments = 100;
            }
            // Re-generate the model using low number of segments
            std::vector<glm::vec3> curvePoints;
            if (method == 1) {
                // Generate all points for the Bezier curve
                curvePoints = deCasteljau(
                        pointsList.at(0).vertices, segments);
                // Append the last point
                curvePoints.emplace_back(pointsList.at(0).vertices.back());
            } else {
                // Generate all points for the B-spline curve
                curvePoints = pointsList.at(0).vertices;
                // The last point should be ignored here
                curvePoints.pop_back();
                // Use 'the chasing game' to generate points in the curve
                while (!curvePoints.empty() && curvePoints.size() < segments) {
                    chasingGame(curvePoints);
                }
                // Append the last point
                curvePoints.emplace_back(pointsList.at(0).vertices.back());
            }
            auto temp = lathe(curvePoints, segments);
            objectsList.at(0).vertices.resize(temp.size());
            objectsList.at(0).colors.resize(temp.size());
            objectsList.at(0).normals.resize(temp.size());
            objectsList.at(0).uvs.resize(temp.size());

            {
                omp_set_num_threads(numberOfThreads);
                #pragma omp parallel for
                for (size_t i = 0; i < temp.size(); ++i) {
                    objectsList.at(0).vertices.at(i) = std::get<0>(temp.at(i));
                    objectsList.at(0).colors.at(i) = WHITE;
                    objectsList.at(0).normals.at(i) = std::get<1>(temp.at(i));
                    objectsList.at(0).uvs.at(i) = std::get<2>(temp.at(i));
                }
            }

            // Delete old VAO, VBO
            RenderingEngine::deleteBufferData(objectsList.at(0));
            // Generate new VAO, VBO
            RenderingEngine::assignBuffers(objectsList.at(0));
            RenderingEngine::setBufferData(objectsList.at(0));

            // Update the uniform
            shaderOfModel->use();
            if (useTexture) {
                fprintf(stdout, "Texture applied\n");
                materialAmbient = {0.95, 0.95, 0.95};
                materialDiffuse = {0.9, 0.9, 0.9};
                shaderOfModel->setter_vec3f("materialAmbient", materialAmbient);
                shaderOfModel->setter_vec3f("materialDiffuse", materialDiffuse);
                shaderOfModel->setter_int("useTexture", 1);
            } else {
                fprintf(stdout, "Texture removed\n");
                materialAmbient = {1.0f, 0.54f, 0.35f};
                materialDiffuse = {1.0f, 0.54f, 0.35f};
                shaderOfModel->setter_vec3f("materialAmbient", materialAmbient);
                shaderOfModel->setter_vec3f("materialDiffuse", materialDiffuse);
                shaderOfModel->setter_int("useTexture", 0);
            }
        }
    }
}

// The callback executed when any error occurs
void errorCallback(int error, const char *description) {
    fprintf(stderr, "GLFW ERROR Code %d:\n%s\n", error, description);
}

// The print function for colored output
void colorPrint(const std::string &colorType, const std::string &output) {
    std::cout << colorType << output << DEFAULT_COLOR;
}

// Query all basic information
void queryBasicInformation(GLFWwindow *window) {

    // Show GL Version
    const char *opengl_version = reinterpret_cast<const char *>(glGetString(
            GL_VERSION));
    const char *glsl_version = reinterpret_cast<const char *>(glGetString(
            GL_SHADING_LANGUAGE_VERSION));
    const char *renderer_version = reinterpret_cast<const char *>(glGetString(
            GL_RENDERER));

    colorPrint(WHITE_BOLD_STRING, "OpenGL version: ");
    fprintf(stdout, "%s\n", opengl_version);

    colorPrint(WHITE_BOLD_STRING, "GLSL version: ");
    fprintf(stdout, "%s\n", glsl_version);

    colorPrint(WHITE_BOLD_STRING, "Render engine info: ");
    fprintf(stdout, "%s\n", renderer_version);

    colorPrint(WHITE_BOLD_STRING, "GLFW version:");
    int major, minor, rev;
    glfwGetVersion(&major, &minor, &rev);
    if (major) {
        fprintf(stdout, " Major: %d", major);
    }
    if (minor) {
        fprintf(stdout, " Minor: %d", minor);
    }
    if (rev) {
        fprintf(stdout, " Revision: %d\n", rev);
    }

    // Show the size of the current window
    int tempWidth;
    int tempHeight;
    glfwGetWindowSize(window, &tempWidth, &tempHeight);
    fprintf(stdout, "\n");
    colorPrint(WHITE_BOLD_STRING, "Current width of window  : ");
    fprintf(stdout, "%d\n", tempWidth);
    colorPrint(WHITE_BOLD_STRING, "Current height of window : ");
    fprintf(stdout, "%d\n", tempHeight);

    // Show the current viewport
    colorPrint(WHITE_BOLD_STRING, "Current viewport : ");
    switch (viewport) {
        case 1:
            fprintf(stdout, "Profile\n");
            break;
        case 2:
            fprintf(stdout, "Perspective\n");
            break;
        default:
            fprintf(stdout, "Parallel\n");
            break;
    }

    // Show the type of curve and the number of control points/points before subdivision
    if (method == 1) {
        colorPrint(WHITE_BOLD_STRING, "Type of curve : ");
        fprintf(stdout, "Bezier curve\n");
        colorPrint(WHITE_BOLD_STRING, "Number of control points : ");
        fprintf(stdout, "%d\n",
                static_cast<int>(pointsList.at(0).vertices.size()) - 1);
    } else {
        colorPrint(WHITE_BOLD_STRING, "Type of curve : ");
        fprintf(stdout, "B-spline curve\n");
        colorPrint(WHITE_BOLD_STRING, "Number of points before subdivision: ");
        fprintf(stdout, "%d\n",
                static_cast<int>(pointsList.at(0).vertices.size()) - 1);
    }

    // Show the light info
    colorPrint(WHITE_BOLD_STRING, "Light direction    : ");
    std::cout << glm::to_string(lightDirection) << std::endl;

    // Show the material info
    colorPrint(WHITE_BOLD_STRING, "Material ambient   : ");
    std::cout << glm::to_string(materialAmbient) << std::endl;
    colorPrint(WHITE_BOLD_STRING, "Material diffuse   : ");
    std::cout << glm::to_string(materialDiffuse) << std::endl;
    colorPrint(WHITE_BOLD_STRING, "Material specular  : ");
    std::cout << glm::to_string(materialSpecular) << std::endl;
    colorPrint(WHITE_BOLD_STRING, "Material shininess : ");
    std::cout << shininess << std::endl;

    // Show if we apply the texture
    colorPrint(WHITE_BOLD_STRING, "Texture applied    : ");
    std::cout << std::boolalpha << useTexture;
}

// The main logic of insertion of a point when the position of the cursor is given
void insertAPoint(GLFWwindow *window) {

    int temp_window_width;
    int temp_window_height;
    double current_mouse_x;
    double current_mouse_y;

    glfwGetCursorPos(window, &current_mouse_x, &current_mouse_y);
    glfwGetWindowSize(window, &temp_window_width,
                      &temp_window_height);

    // The <x, y> value of the position being clicked in the NDC system
    auto positionClicked = pixel2Coord(
            current_mouse_x,
            current_mouse_y,
            temp_window_width,
            temp_window_height);

    // Re-insert if the clicked position is out of boundary
    if (positionClicked.first < -1.0f || positionClicked.first > 0.0f) {
        fprintf(stdout, "Click out of boundary!\n");
        return;
    }
    if (positionClicked.second > 1.0f || positionClicked.second < -0.9f) {
        fprintf(stdout, "Click out of boundary!\n");
        return;
    }

    glm::vec3 newPoint = glm::vec3(
            positionClicked.first,
            positionClicked.second,
            0.0f);

    // Update pointsList.at(0)
    pointsList.at(0).vertices.emplace_back(newPoint);
    pointsList.at(0).colors.emplace_back(BLUE);
    __gnu_parallel::sort(pointsList.at(0).vertices.begin(),
              pointsList.at(0).vertices.end(),
              comparator);
    RenderingEngine::deleteBufferData(pointsList.at(0));
    RenderingEngine::assignBuffers(pointsList.at(0));
    RenderingEngine::setBufferData(pointsList.at(0));

    // Update pointsList.at(1)
    // right-pad one more dummy element
    pointsList.at(1).vertices.emplace_back(0.0f, 0.0f, 0.0f);

    {
        omp_set_num_threads(numberOfThreads);
        #pragma omp parallel for
        for (size_t i = 0; i < pointsList.at(0).vertices.size(); ++i) {
            pointsList.at(1).vertices.at(i).x = pointsList.at(0).vertices.at(
                    i).x;
            pointsList.at(1).vertices.at(i).y = pointsList.at(0).vertices.at(
                    i).y;
            pointsList.at(1).vertices.at(i).z = -1.0f;
        }
    }

    pointsList.at(1).colors.back() = YELLOW;
    pointsList.at(1).colors.emplace_back(RED);
    RenderingEngine::deleteBufferData(pointsList.at(1));
    RenderingEngine::assignBuffers(pointsList.at(1));
    RenderingEngine::setBufferData(pointsList.at(1));

    // Update pointsList.at(4)
    if (method == 1) {

        unsigned int segments{};
        if (!useTexture) {
            if (useCLion) {
                segments = 100;
            } else {
                segments = 1000;
            }
        } else {
            segments = 100;
        }

        auto bezierCurvePoints = deCasteljau(pointsList.at(0).vertices,
                                             segments);
        // Empty the previous data since the length of the array is changed
        std::vector<glm::vec3>().swap(pointsList.at(4).vertices);
        std::vector<glm::vec3>().swap(pointsList.at(4).colors);
        // Update data in the container
        {
            pointsList.at(4).vertices.resize(bezierCurvePoints.size());
            pointsList.at(4).colors.resize(bezierCurvePoints.size());
            omp_set_num_threads(numberOfThreads);
            #pragma omp parallel for
            for (size_t i = 0; i < bezierCurvePoints.size(); ++i) {
                pointsList.at(4).vertices.at(i) = bezierCurvePoints.at(i);
                pointsList.at(4).colors.at(i) = WHITE;
            }
        }
    } else {
        // Remove all old points in the b-spline
        std::vector<glm::vec3>().swap(pointsList.at(4).vertices);
        std::vector<glm::vec3>().swap(pointsList.at(4).colors);
        // Redo 'the chasing game'
        pointsList.at(4).vertices = pointsList.at(0).vertices;
        pointsList.at(4).vertices.pop_back();
        while (!pointsList.at(4).vertices.empty() &&
               pointsList.at(4).vertices.size() < bspline_segment_threshold) {
            chasingGame(pointsList.at(4).vertices);
        }
        pointsList.at(4).vertices.emplace_back(
                pointsList.at(0).vertices.back());
        pointsList.at(4).colors.resize(pointsList.at(4).vertices.size());
        std::fill(pointsList.at(4).colors.begin(),
                  pointsList.at(4).colors.end(),
                  WHITE);
    }
    // Delete old VAO, VBO of pointsList.at(4)
    RenderingEngine::deleteBufferData(pointsList.at(4));
    // Generate new VAO, VBO of pointsList.at(4)
    RenderingEngine::assignBuffers(pointsList.at(4));
    RenderingEngine::setBufferData(pointsList.at(4));

    fprintf(stdout, "Inserted a point at (%lf, %lf) ...\n",
            positionClicked.first,
            positionClicked.second);
    fprintf(stdout, "Exit INSERT mode\n");
    insertMode = false;
    isModified = true;
}

// The main logic of moving a point when the position of the cursor is given
void moveAPoint(GLFWwindow *window, double x, double y) {

    int temp_window_width;
    int temp_window_height;
    glfwGetWindowSize(window, &temp_window_width, &temp_window_height);
    auto positionPressed = pixel2Coord(x, y,
                                       temp_window_width,
                                       temp_window_height);

    // Calculate the distance between the selected point and the pixel clicked
    double dist = (pointsList.at(1).vertices.at(indexOfPointSelected).x -
                   positionPressed.first) *
                  (pointsList.at(1).vertices.at(indexOfPointSelected).x -
                   positionPressed.first) +
                  (pointsList.at(1).vertices.at(indexOfPointSelected).y -
                   positionPressed.second) *
                  (pointsList.at(1).vertices.at(indexOfPointSelected).y -
                   positionPressed.second);

    // If distance between the selected point and the pixel clicked is
    // than the threshold, we just ignore it
    if (dist < THRESHOLD * 20.0) {

        // Make sure the user cannot move the point out of the boundary
        Utility::clamp(positionPressed.first, -1.0, 0.0);
        Utility::clamp(positionPressed.second, -0.9, 1.0);

        pointsList.at(1).vertices.at(
                indexOfPointSelected).x = static_cast<float>(positionPressed.first);
        pointsList.at(1).vertices.at(
                indexOfPointSelected).y = static_cast<float>(positionPressed.second);
        // Delete old VAO, VBO of pointsList.at(1)
        RenderingEngine::deleteBufferData(pointsList.at(1));
        // Generate new VAO, VBO of pointsList.at(1)
        RenderingEngine::assignBuffers(pointsList.at(1));
        RenderingEngine::setBufferData(pointsList.at(1));

        pointsList.at(0).vertices.at(
                indexOfPointSelected).x = static_cast<float>(positionPressed.first);
        pointsList.at(0).vertices.at(
                indexOfPointSelected).y = static_cast<float>(positionPressed.second);
        // Delete old VAO, VBO of pointsList.at(0)
        RenderingEngine::deleteBufferData(pointsList.at(0));
        // Generate new VAO, VBO of pointsList.at(0)
        RenderingEngine::assignBuffers(pointsList.at(0));
        RenderingEngine::setBufferData(pointsList.at(0));

        unsigned int segments{};
        if (useCLion) {
            segments = 100;
        } else {
            segments = 1000;
        }

        // Regenerate all points of the curve
        if (method == 1) {
            auto bezierCurvePoints = deCasteljau(pointsList.at(0).vertices,
                                                 segments);
            // Update data in the container
            {
                omp_set_num_threads(numberOfThreads);
                #pragma omp parallel for
                for (size_t i = 0; i < bezierCurvePoints.size(); ++i) {
                    pointsList.at(4).vertices.at(i) = bezierCurvePoints.at(i);
                }
            }
        } else {
            // Remove all old points in the b-spline
            std::vector<glm::vec3>().swap(pointsList.at(4).vertices);
            std::vector<glm::vec3>().swap(pointsList.at(4).colors);
            // Redo 'the chasing game'
            pointsList.at(4).vertices = pointsList.at(0).vertices;
            pointsList.at(4).vertices.pop_back();
            while (!pointsList.at(4).vertices.empty() &&
                   pointsList.at(4).vertices.size() <
                   bspline_segment_threshold) {
                chasingGame(pointsList.at(4).vertices);
            }
            pointsList.at(4).vertices.emplace_back(
                    pointsList.at(0).vertices.back());

            pointsList.at(4).colors.resize(pointsList.at(4).vertices.size());
            {
                omp_set_num_threads(numberOfThreads);
                #pragma omp parallel for
                for (size_t i = 0; i < pointsList.at(4).colors.size(); ++i) {
                    pointsList.at(4).colors.at(i) = WHITE;
                }
            }
        }

        // Delete old VAO, VBO of pointsList.at(4)
        RenderingEngine::deleteBufferData(pointsList.at(4));
        // Generate new VAO, VBO of pointsList.at(4)
        RenderingEngine::assignBuffers(pointsList.at(4));
        RenderingEngine::setBufferData(pointsList.at(4));

        fprintf(stdout, "Point moved to (%lf, %lf)\n",
                positionPressed.first,
                positionPressed.second);
        isModified = true;
    } else {
        fprintf(stdout,
                "The pixel clicked is TOO FAR AWAY from the selected point!\n");
    }
}

// Convert the coordinate of the pixel in the screen currently clicked
// by mouse to the coordinate of the NDC system
std::pair<double, double> pixel2Coord(
        const double &mouse_x,
        const double &mouse_y,
        const int &window_width,
        const int &window_height) {

    glm::dvec4 ray_clip = glm::dvec4(
            2.0 * mouse_x / window_width - 1.0,
            1.0 - 2.0 * mouse_y / window_height,
            -1.0,
            1.0);

    glm::dmat4 projection = glm::ortho(-1.0, 1.0,
                                       -1.0,
                                       1.0,
                                       -1.0, 1.0);

    glm::vec4 ray_eye = glm::inverse(projection) * ray_clip;
    return std::make_pair<double, double>(ray_eye.x, ray_eye.y);
}

// Select a point base on the pixel being clicked
void selectAPoint(GLFWwindow *window) {

    int temp_window_width;
    int temp_window_height;
    double current_mouse_x;
    double current_mouse_y;

    glfwGetCursorPos(window, &current_mouse_x, &current_mouse_y);
    glfwGetWindowSize(window, &temp_window_width,
                      &temp_window_height);

    // The <x, y> value of the position being clicked in the NDC system
    auto positionClicked = pixel2Coord(
            current_mouse_x,
            current_mouse_y,
            temp_window_width,
            temp_window_height);

    // Find all points in pointsList.at(1) to obtain the point
    // which is the closest to the position clicked in O(n)
    auto closestPointIter = std::min_element(
            pointsList.at(1).vertices.begin(),
            pointsList.at(1).vertices.end(),
            [&](const glm::vec3 &lhs, const glm::vec3 &rhs) {

                auto dist0 =
                        (lhs.x - positionClicked.first) *
                        (lhs.x - positionClicked.first) +
                        (lhs.y - positionClicked.second) *
                        (lhs.y - positionClicked.second);

                auto dist1 =
                        (rhs.x - positionClicked.first) *
                        (rhs.x - positionClicked.first) +
                        (rhs.y - positionClicked.second) *
                        (rhs.y - positionClicked.second);

                return (dist0 < dist1);
            });
    // If the red point(the center of the bottom of the pottery) is clicked, we ignore it
    if (closestPointIter == pointsList.at(1).vertices.end() - 1) {
        return;
    }

    // If its distance is larger than threshold, we ignore it
    // Otherwise, we make it green which indicates a selected point
    double dist = (closestPointIter->x - positionClicked.first) *
                  (closestPointIter->x - positionClicked.first) +
                  (closestPointIter->y - positionClicked.second) *
                  (closestPointIter->y - positionClicked.second);
    if (dist < THRESHOLD) {
        indexOfPointSelected = static_cast<int>(closestPointIter -
                                                pointsList.at(
                                                        1).vertices.begin());
        pointsList.at(1).colors.at(
                indexOfPointSelected) = GREEN;
        // Delete old VAO, VBO
        RenderingEngine::deleteBufferData(pointsList.at(1));
        // Generate new VAO, VBO
        RenderingEngine::assignBuffers(pointsList.at(1));
        RenderingEngine::setBufferData(pointsList.at(1));
        fprintf(stdout, "Point selected at (%lf, %lf)\n",
                positionClicked.first,
                positionClicked.second);
    }
}

// De-select the point being selected
void deselectAPoint() {
    // Store its color to yellow
    pointsList.at(1).colors.at(indexOfPointSelected) = YELLOW;
    // Delete old VAO, VBO
    RenderingEngine::deleteBufferData(pointsList.at(1));
    // Generate new VAO, VBO
    RenderingEngine::assignBuffers(pointsList.at(1));
    RenderingEngine::setBufferData(pointsList.at(1));
    indexOfPointSelected = -1;
    fprintf(stdout, "Point de-selected\n");
}

// Delete the selected point and redraw the profile
void deleteSelectedPoint() {

    // Remove the point from the arrays
    pointsList.at(0).vertices.erase(
            pointsList.at(0).vertices.begin() + indexOfPointSelected);
    pointsList.at(0).colors.erase(
            pointsList.at(0).colors.begin() + indexOfPointSelected);
    pointsList.at(1).vertices.erase(
            pointsList.at(1).vertices.begin() + indexOfPointSelected);
    pointsList.at(1).colors.erase(
            pointsList.at(1).colors.begin() + indexOfPointSelected);
    // Reset indexOfPointSelected
    indexOfPointSelected = -1;
    // Delete old VAO, VBO
    RenderingEngine::deleteBufferData(pointsList.at(0));
    RenderingEngine::deleteBufferData(pointsList.at(1));
    // Generate new VAO, VBO
    RenderingEngine::assignBuffers(pointsList.at(0));
    RenderingEngine::setBufferData(pointsList.at(0));
    RenderingEngine::assignBuffers(pointsList.at(1));
    RenderingEngine::setBufferData(pointsList.at(1));

    // Regenerate all points of the curve
    if (method == 1) {

        unsigned int segments{};
        if (useCLion) {
            segments = 100;
        } else {
            segments = 1000;
        }

        auto bezierCurvePoints = deCasteljau(pointsList.at(0).vertices,
                                             segments);
        // Update data in the container
        // Empty the previous data since the length of the array is changed
        std::vector<glm::vec3>().swap(pointsList.at(4).vertices);
        std::vector<glm::vec3>().swap(pointsList.at(4).colors);
        pointsList.at(4).vertices = bezierCurvePoints;
        pointsList.at(4).colors.resize(bezierCurvePoints.size());
        std::fill(pointsList.at(4).colors.begin(),
                  pointsList.at(4).colors.end(),
                  WHITE);

    } else {
        // Remove all old points in the b-spline
        std::vector<glm::vec3>().swap(pointsList.at(4).vertices);
        std::vector<glm::vec3>().swap(pointsList.at(4).colors);
        // Redo 'the chasing game'
        pointsList.at(4).vertices = pointsList.at(0).vertices;
        pointsList.at(4).vertices.pop_back();

        while (!pointsList.at(4).vertices.empty() &&
               pointsList.at(4).vertices.size() < bspline_segment_threshold) {
            chasingGame(pointsList.at(4).vertices);
        }
        pointsList.at(4).vertices.emplace_back(
                pointsList.at(0).vertices.back());
        pointsList.at(4).colors.resize(pointsList.at(4).vertices.size());
        std::fill(pointsList.at(4).colors.begin(),
                  pointsList.at(4).colors.end(),
                  WHITE);
    }

    // Delete old VAO, VBO of pointsList.at(4)
    RenderingEngine::deleteBufferData(pointsList.at(4));
    // Generate new VAO, VBO of pointsList.at(4)
    RenderingEngine::assignBuffers(pointsList.at(4));
    RenderingEngine::setBufferData(pointsList.at(4));

    // Prompt a message to show the deletion is successful.
    fprintf(stdout, "Point deleted\n");
    isModified = true;
}

std::vector<std::tuple<glm::vec3, glm::vec3, glm::vec2> >
lathe(const std::vector<glm::vec3> &pts,
      unsigned int segments) {

    // Pre-calculate circle points
    std::vector<glm::vec2> circlePoints(segments + 1);
    double angle{};
    for (unsigned int i = 0; i <= segments; ++i) {
        // angle = 2 * pi * r * (i / total_segments)
        angle = (i / static_cast<double>(segments)) * M_PI * 2.0;
        circlePoints.at(i) = glm::vec2(cos(angle), sin(angle));
    }

    // Fill each layer
    std::vector<std::vector<glm::vec3> > layers(pts.size(),
                                                std::vector<glm::vec3>(
                                                        circlePoints.size()));
    for (size_t i = 0; i != pts.size(); ++i) {
        for (size_t j = 0; j != circlePoints.size(); ++j) {
            layers.at(i).at(j) = glm::vec3(
                    circlePoints.at(j) * pts.at(i).x,
                    pts.at(i).y);
        }
    }

    // Move through layers by generating 2 adjacent triangles
    size_t length = 6 * (layers.size() - 1) * (circlePoints.size() - 1);
    std::vector<std::tuple<glm::vec3, glm::vec3, glm::vec2> > vertices(length);
    size_t indexOfVertices = 0;

    for (size_t i = 1; i != layers.size(); ++i) {
        const auto &previousLayer = layers.at(i - 1);
        const auto &currentLayer = layers.at(i);
        for (size_t j = 1; j != circlePoints.size(); ++j) {
            //    upper = current layer
            //        UL -- UR
            // left   | 0 /  |  right
            // = j-1  |  / 1 |  = j
            //        LL -- LR
            //    lower = previous layer
            const auto & lowerLeft = previousLayer.at(j - 1); // lower-left (LL)
            const auto & lowerRight = previousLayer.at(j); // lower-right (LR)
            const auto & upperLeft = currentLayer.at(j - 1); // upper-left (UL)
            const auto & upperRight = currentLayer.at(j); // upper-right (UR)

            // triangle0: LL -> UR -> UL
            const auto normal0 = glm::normalize(
                    glm::cross(
                            upperRight - lowerLeft,
                            upperLeft - lowerLeft));

            vertices.at(indexOfVertices++) = std::make_tuple(
                    lowerLeft,
                    normal0,
                    glm::vec2(0.0f, 0.0f));

            vertices.at(indexOfVertices++) = std::make_tuple(
                    upperRight,
                    normal0,
                    glm::vec2(1.0f, 1.0f));

            vertices.at(indexOfVertices++) = std::make_tuple(
                    upperLeft,
                    normal0,
                    glm::vec2(0.0f, 1.0f));

            // triangle1: LL -> LR -> UR
            const auto normal1 = glm::normalize(glm::cross(
                    lowerRight - lowerLeft,
                    upperLeft - lowerLeft));

            vertices.at(indexOfVertices++) = std::make_tuple(
                    lowerLeft,
                    normal1,
                    glm::vec2(0.0f, 0.0f));

            vertices.at(indexOfVertices++) = std::make_tuple(
                    lowerRight,
                    normal1,
                    glm::vec2(1.0f, 0.0f));

            vertices.at(indexOfVertices++) = std::make_tuple(
                    upperRight,
                    normal1,
                    glm::vec2(1.0f, 1.0f));
        }
    }
    return vertices;
}

// A comparator for sorting an array of glm::vec3 by its y value in descending order
// If their y-values are the same, compare their x-values in descending order
bool comparator(const glm::vec3 &lhs, const glm::vec3 &rhs) {
    if (Utility::threeWayComparator(lhs.y - rhs.y) == 0) {
        return (lhs.x < rhs.x);
    }
    return (lhs.y > rhs.y);
}

// Calculate the array of C(t) of points of Bezier curve
// if control points and segments are given using de Casteljau's algorithm
// Time complexity: O(segments * n^2)
// of the bottom of the pottery and should not be involved in the calculation
// Reference: https://pages.mtu.edu/~shene/COURSES/cs3621/NOTES/spline/Bezier/de-casteljau.html
std::vector<glm::vec3> deCasteljau(
        const std::vector<glm::vec3> &controlPoints, unsigned int segments) {

    // We ignore the last element in controlPoints since it is the center
    std::vector<glm::vec2> temp(controlPoints.size() - 1);
    std::vector<glm::vec3> output;

    // Handle the corner case
    if (temp.empty()) {
        return controlPoints;
    }

    float step = 1.0f / static_cast<float>(segments);
    int numberOfControlPoints = static_cast<int>(controlPoints.size() - 1);

    for (float t = 0.0f; t <= 1.0f; t += step) {
        for (int k = 1; k < numberOfControlPoints; ++k) {
            for (int i = 0; i < numberOfControlPoints - k; ++i) {
                // In the 1st iteration, we use the control points to do calculation
                if (k == 1) {
                    temp.at(i).x = (1.0f - t) * controlPoints.at(i).x +
                                   t * controlPoints.at(i + 1).x;
                    temp.at(i).y = (1.0f - t) * controlPoints.at(i).y +
                                   t * controlPoints.at(i + 1).y;
                }
                    // Otherwise, we do the calculation according to the result from previous calculations
                else {
                    temp.at(i).x =
                            (1.0f - t) * temp.at(i).x + t * temp.at(i + 1).x;
                    temp.at(i).y =
                            (1.0f - t) * temp.at(i).y + t * temp.at(i + 1).y;
                }
            }
        }
        output.emplace_back(temp.at(0), 0.0f);
    }
    return output;
}

// The implementation of 'the chasing game' subdivision scheme for 1 iteration
void chasingGame(std::vector<glm::vec3> &points) {

    std::vector<glm::vec3> middlePoints(points.size() - 1);
    auto temp_iter = middlePoints.begin();
    for (size_t i = 0; i != points.size() - 1; ++i) {
        *temp_iter = (points.at(i) + points.at(i + 1)) / 2.0f;
        ++temp_iter;
    }
    // Insert all middle points into points as newPoints
    std::vector<glm::vec3> newPoints(points.size() + middlePoints.size());
    bool change = true;
    auto points_iter = points.cbegin();
    auto middlePoints_iter = middlePoints.cbegin();
    for (size_t i = 0; i != newPoints.size(); ++i) {
        if (change) {
            newPoints.at(i) = *points_iter;
            ++points_iter;
            change = false;
        } else {
            newPoints.at(i) = *middlePoints_iter;
            ++middlePoints_iter;
            change = true;
        }
    }
    // Obtain middle points of newPoints
    std::vector<glm::vec3> newMiddlePoints(newPoints.size() + 1);
    temp_iter = newMiddlePoints.begin();
    // Insert a copy of the first point
    *temp_iter = newPoints.front();
    ++temp_iter;
    for (size_t i = 0; i != newPoints.size() - 1; ++i) {
        *temp_iter = (newPoints.at(i) + newPoints.at(i + 1)) / 2.0f;
        ++temp_iter;
    }
    // Insert a copy of the last point
    *temp_iter = newPoints.back();
    // Copy to points
    points = newMiddlePoints;
}

// Get current time as a string
std::string getCurrentTime() {
    static_assert(std::is_integral<std::chrono::system_clock::rep>::value);
    auto now = std::chrono::system_clock::to_time_t(
            std::chrono::system_clock::now());
    auto temp = *std::gmtime(&now);
    std::stringstream ss;
    const std::string format = "%Y_%m_%d_%H_%M_%S.dat";
    ss << std::put_time(&temp, format.c_str());
    return ss.str();
}

// Serialization:
//
// 1. Save the method to generate the curve to 'filename'
// 2. If method == 1, we store the x, y coordinates of each control point per line
// 3. If method == 2, we store the x, y coordinates of point before subdivision per line
void serialize() {

    // Use current time + .dat as the new filename to save data
    std::string filepath;
    if (useCLion) {
        filepath =
                "/Users/hshen/CLionProject/Assignment4/save/" +
                getCurrentTime();
    } else {
        filepath = std::string(std::filesystem::current_path()) + "/save/" +
                   getCurrentTime();
    }

    // Output to file and overwrite all previous data
    std::ofstream out(filepath);
    out << method << "\n";
    for (const auto &i : pointsList.at(0).vertices) {
        out << i.x << " " << i.y << "\n";
    }
    fprintf(stdout, "Current data saved to %s successfully\n",
            filepath.c_str());
}

// De-serialization:
//
// Load the data saved in 'filename' and write the position of sorted control points
// to 'pointsList'
//
// About the format of the file:
//
// 1. the first line after comments indicates the method to generate a curve: 1 or 2
// 2. If method == 1, remaining lines indicate the x, y coordinates of each control point
// 3. If method == 2, remaining lines indicate the x, y coordinates of each point before subdivision
// 4. x and y must satisfy that -1.0 <= x <= 0.0 and -0.9 <= y <= 1.0
// 5. no duplicated points allowed
// 6. the data must saved using .dat as its suffix
// 7. the point (0.0f, -0.9f) should always exist
// 8. if the file contains any invalid data, the parser will stop parsing and print an error message then abort
void deserialize(const std::string &filename) {

    if (!Utility::isRegularFile(filename)) {
        fprintf(stderr, "%s is not a valid file!\n", filename.c_str());
        exit(EXIT_FAILURE);
    }
    if (!Utility::isDatFile(filename)) {
        fprintf(stderr, "%s is not a .dat file!\n",
                filename.c_str());
        exit(EXIT_FAILURE);
    }
    if (!Utility::hasReadPermission(filename)) {
        fprintf(stderr,
                "The current user has no READ permission for the file!\n");
        exit(EXIT_FAILURE);
    }

    std::ifstream ifs(filename);
    if (ifs.good()) {

        std::unordered_set<glm::vec2, Utility::glm_vec2_hash> controlPointsSet;
        std::vector<glm::vec2> tempVector;
        std::vector<std::string> contents;
        std::string currentLine;

        while (std::getline(ifs, currentLine)) {
            contents.emplace_back(currentLine);
        }
        // The number of lines in the file is not valid
        if (contents.size() <= 1) {
            fprintf(stderr,
                    "The number of lines in the file is not valid, abort!\n");
            exit(EXIT_FAILURE);
        }
        // Invalid number of method
        if (contents.at(0) != "1" && contents.at(0) != "2") {
            fprintf(stderr, "Invalid number of method, abort!\n");
            exit(EXIT_FAILURE);
        }
        method = std::stoi(contents.at(0));
        for (size_t i = 1; i != contents.size(); ++i) {
            auto temp = Utility::splitByWhitespaces(contents.at(i));
            // Invalid number of the coordinate
            if (temp.size() != 2) {
                fprintf(stderr, "Invalid number of a coordinate, abort!\n");
                exit(EXIT_FAILURE);
            }
            try {
                glm::vec2 tempPair(
                        std::stof(temp.at(0)),
                        std::stof(temp.at(1)));

                // Abort if x or y is out of boundary
                // x > 0.0
                if (Utility::threeWayComparator(tempPair.x) > 0) {
                    fprintf(stderr, "x is out of boundary, abort!\n");
                    exit(EXIT_FAILURE);
                }
                // x < -1.0
                if (Utility::threeWayComparator(tempPair.x + 1.0f) < 0) {
                    fprintf(stderr, "x is out of boundary, abort!\n");
                    exit(EXIT_FAILURE);
                }
                // y > 1.0
                if (Utility::threeWayComparator(tempPair.y - 1.0f) > 0) {
                    fprintf(stderr, "y is out of boundary, abort!\n");
                    exit(EXIT_FAILURE);
                }
                // y < -0.9
                if (Utility::threeWayComparator(tempPair.y + 0.9f) < 0) {
                    fprintf(stderr, "y is out of boundary, abort!\n");
                    exit(EXIT_FAILURE);
                }
                // Abort if duplicates found
                if (controlPointsSet.find(tempPair) != controlPointsSet.end()) {
                    fprintf(stderr, "Duplicate points found, abort!\n");
                    exit(EXIT_FAILURE);
                }
                controlPointsSet.insert(tempPair);
                tempVector.emplace_back(tempPair);
            } catch (...) {
                // Invalid format of the coordinate
                fprintf(stderr, "Invalid format of the coordinate, abort!\n");
                exit(EXIT_FAILURE);
            }
        }

        // Copy all elements in controlPointsSet to pointsList.at(0) and
        // generate their color as well
        pointsList.emplace_back(Geometry());
        pointsList.at(0).vertices.resize(tempVector.size());
        pointsList.at(0).colors.resize(tempVector.size());

        {
            omp_set_num_threads(numberOfThreads);
            #pragma omp parallel for
            for (size_t i = 0; i < tempVector.size(); ++i) {
                pointsList.at(0).vertices.at(i) = glm::vec3(
                        tempVector.at(i).x,
                        tempVector.at(i).y,
                        0.0f
                );
                pointsList.at(0).colors.at(i) = BLUE;
            }
        }

        // Make sure the x and y of the last point is (0.0f, -0.9f)
        if (Utility::threeWayComparator(pointsList.at(0).vertices.back().x) !=
            0) {
            fprintf(stderr, "Point (0.0, -0.9) does not exist!\n");
            exit(EXIT_FAILURE);
        }
        if (Utility::threeWayComparator(
                pointsList.at(0).vertices.back().y + 0.9f) != 0) {
            fprintf(stderr, "Point (0.0, -0.9) does not exist!\n");
            exit(EXIT_FAILURE);
        }

        // Copy all elements in pointsList.at(0) to pointsList.at(1) and
        // generate their color as well
        pointsList.emplace_back(Geometry());
        pointsList.at(1).vertices.resize(pointsList.at(0).vertices.size());
        pointsList.at(1).colors.resize(pointsList.at(0).vertices.size());

        {
            omp_set_num_threads(numberOfThreads);
            #pragma omp parallel for
            for (size_t i = 0; i < pointsList.at(0).vertices.size(); ++i) {
                pointsList.at(1).vertices.at(i) = glm::vec3(
                        pointsList.at(0).vertices.at(i).x,
                        pointsList.at(0).vertices.at(i).y,
                        -1.0f);
                pointsList.at(1).colors.at(i) = YELLOW;
            }
        }
        // Remember to color the last point red since
        // it is the center of the bottom of the pottery
        pointsList.at(1).colors.back() = RED;

        // Set the drawMode for pointsList.at(0)
        pointsList.at(0).drawMode = GL_LINE_STRIP;

        // Set the drawMode for pointsList.at(1)
        pointsList.at(1).drawMode = GL_POINTS;
    } else {
        fprintf(stderr,
                "Cannot the parse the file!\n");
        exit(EXIT_FAILURE);
    }
}

// Print the current light direction if there is an update of it
void printLightDirection() {
    fprintf(stdout, "Current vector of light direction: (%.2f, %.2f, %.2f)\n",
            -lightDirection.x, -lightDirection.y,
            -lightDirection.z);
}

// Generate the checkerboard texture (procedural texture)
// Reference: https://www.glprogramming.com/red/chapter09.html
void generateCheckerboard() {
    for (unsigned int i = 0; i != IMAGE_HEIGHT; ++i) {
        for (unsigned int j = 0; j != IMAGE_WIDTH; ++j) {
            unsigned int c = ((((i & 0x1) == 0) ^ (((j & 0x1)) == 0))) * 255;
            checkerBoard[i][j][0] = static_cast<GLubyte>(c);
            checkerBoard[i][j][1] = static_cast<GLubyte>(c);
            checkerBoard[i][j][2] = static_cast<GLubyte>(c);
            checkerBoard[i][j][3] = static_cast<GLubyte>(255);
        }
    }
}

// Bind the checkerboard texture to fragment shader
void bindTexture() {

    glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
    glGenTextures(1, &textureID);
    glBindTexture(GL_TEXTURE_2D, textureID);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER,
                    GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,
                    GL_NEAREST);
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, IMAGE_WIDTH,
                 IMAGE_HEIGHT, 0, GL_RGBA, GL_UNSIGNED_BYTE,
                 checkerBoard);

    // Clean up and reallocate the space
    glBindTexture(GL_TEXTURE_2D, 0);
    glPixelStorei(GL_UNPACK_ALIGNMENT, 4);    // Restore the default alignment
    glActiveTexture(GL_TEXTURE0);
    glBindTexture(GL_TEXTURE_2D, textureID);

    // Write to the shader
    shaderOfModel->use();
    glUniform1i(glGetUniformLocation(shaderOfModel->programId, "texture0"),
                0);
}

// Deallocate texture-related objects
void destroyTexture() {
    glBindTexture(GL_TEXTURE_2D, 0);
    glDeleteTextures(1, &textureID);
}

// Print the usage if the arguments provided are not valid.
void printUsage() {
    colorPrint(WHITE_BOLD_STRING, "\nUsage: ");
    fprintf(stdout, "./assignment4.out method_to_define_the_curve\n\n"
                    "method_to_define_the_curve: \n"
                    "1. Parametric Bezier curve using de Casteljau's algorithm\n"
                    "2. B-spline subdivision curve using 'the chasing game'\n\n");
    colorPrint(WHITE_BOLD_STRING, "\nUsage: ");
    fprintf(stdout, "./assignment4.out path_of_dat_file\n"
                    "Generate the curve by loading the saved data\n\n"
                    "Example:\n"
                    "./assignment4.out ./save/2019_11_27_14_27_55.dat\n\n");
}

/**
 * Validate all arguments provided, prompt the usage and exit the program if any invalid argument detected.
 * @param argc the number of arguments
 * @param argv the string array of arguments
 */
void argumentsValidation(int argc, char *argv[]) {

    // Check the number of arguments
    if (argc != 2 || std::string(argv[1]) == "--help") {
        printUsage();
        exit(EXIT_SUCCESS);
    }

    // Print the error message and abort the program if the second argument is not correct.
    if (std::string(argv[1]) == "1") {
        method = 1;
        return;
    } else if (std::string(argv[1]) == "2") {
        method = 2;
        return;
    }
    deserialize(std::string(argv[1]));
}

/**
 * the 'main' function.
 * @param argc
 * @param argv
 * @return
 */
int main(int argc, char *argv[]) {

    if (useCLion) {
        method = 1;
        pointSize = 15.0f;
        bspline_segment_threshold = 100;
    } else {
        argumentsValidation(argc, argv);
        pointSize = 10.0f;
        bspline_segment_threshold = 1000;
    }

    // Set the number of threads we are gonna use
    numberOfThreads = omp_get_max_threads() / 2;

    Program p;
    p.start();
    return 0;
}
